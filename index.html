<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>MIUMIU Learn to Code</title>
<style>
/* === CSS Variables & Theme === */

:root{
    /* SCALING */
    /* base sizes stay as ‚Äúdesign‚Äù values */
    --blockH: calc(48px * var(--scale));
    --blockW: calc(48px * var(--scale));
    --btnSmall: calc(42px * var(--scale));

    /* optional: topbar + icons scale too */
    --topbarH: calc(40px * var(--scale));
    --icon-22: calc(22px * var(--scale));
    --icon-32: calc(32px * var(--scale));
    --icon-36: calc(36px * var(--scale));
    --icon-42: calc(42px * var(--scale));

    
    /* COLOURS */
    --bg: #a7a4a4;
    --C1: #ffffff;
    --C2: #fffb01;
    --C3: #fb7eff;
    --cheese: #fcdb7a;
    --cheeseInk: #4B2C82;
    --fn-block-bg: #108204;
    --fn-block-fg: #d8ffd4;
    --fn-locked-bg: #d8f0d6;
    --fn-locked-border: #fa9d9d;
    --function-bar-bg: #d8f0d6;
    --function-bar-border: #aee6a9;
    --home: #bbdfc0;
    --ifBgnd: #ffe9d7;
    --ifLabel: #ff7a00;
    --ink: #23303d;
    --left: #6CC1E5;
    --mhole-blue: #1e88e5;
    --mhole-border-width: 4px;
    --mhole-green: #43a047;
    --mhole-red: #e53935;
    --mhole-yellow: #fdd835;
    --muted: #5a6b7e;
    --play: #63d3a2;
    --repeat: #e2e2e2;
    --repeatInk: #4B2C82;
    --resetPink: #f1bdb1;
    --right: #FFAA4E;
    --run-outline-color: #000;
    --run-outline-offset: 0px;
    --run-outline-width: 4px;
    --start: #c09c7f;
    --step: #FF556B;
    --stepLight: #b5f0d6;
    --straw: #f8f1c7;
    --straw-border: #e9dba3;
    --tile: #bbdfc0;
    --treeBg: #9fcf9f;
    --wallBg: #e9bd8d;
    --repeatUntil: #ead8ff;
    --repeatUntilInk: var(--cheeseInk);
/* === Scaling variables injected (v6.5 scalable) === */
--u: calc(2px * var(--scale));
--space-1: calc(var(--u)*2);
--space-2: calc(var(--u)*3);
--space-3: calc(var(--u)*4);
--space-4: calc(var(--u)*5);
--space-5: calc(var(--u)*6);
--space-6: calc(var(--u)*7);
--space-7: calc(var(--u)*8);
--space-8: calc(var(--u)*10);
--space-9: calc(var(--u)*12);

--radius-1: 8px;
--radius-2: 10px;
--radius-3: 12px;
--radius-4: 14px;
--radius-5: 16px;
--radius-round: 999px;

--font-12: 12px;
--font-16: 16px;
--font-18: 18px;
--font-20: 20px;
--font-22: 22px;
--font-26: 26px;
--font-28: 28px;

--barH: 78px;
--topbarH: 40px;
--icon-22: 22px;
--icon-32: 32px;
--icon-36: 36px;
--icon-42: 42px;
--repeat-icon-menu: 16px;
--repeat-icon-live: 22px;

--border-1: 1px;
--border-2: 2px;
--outline-4: 4px;

--shadow-1: 0 6px 20px rgba(0,0,0,0.08);
--shadow-2: 0 10px 30px rgba(0,0,0,0.15);

--minProgramW: 600px;
--boardBorder: 6px;

--menuRightGap: 55px; /* default for repeat menu; if-menu IF uses 35px */
    --scale: 1;
}

/* === Resets & Base === */

*{
        box-sizing: border-box;
    }

[hidden]{
        display: none!important;
    }

html{
        height: 100%;
    }

body{
        background: var(--bg);
        color: var(--ink);
        font-family: ui-rounded,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,sans-serif;
        margin: 0;
        height: 100%;
        display: flex;
        flex-direction: column;
        min-height: 100svh;
    }

/* === Header & Tools === */

.topbar{
        align-items: center;
        background: #fff;
        border-bottom: var(--border-1) solid #e0e4ea;
        display: grid;
        gap: var(--space-5);
        grid-template-columns: minmax(0,1fr) auto minmax(0,1fr);
        justify-content: space-between;
        padding: var(--space-4) var(--space-6);
        position: sticky;
        top: 0;
        z-index: 10;
    }

#currentUserBadge{
        align-items: center;
        color: #e53935;
        display: inline-flex;
        font-size: var(--font-20);
        font-weight: 700;
        height: var(--topbarH);
        line-height: 1;
    }

.right-tools 
      .dot-sep{
        align-items: center;
        display: inline-flex;
        font-size: 40px;
        font-weight: 700;
        line-height: 1;
        margin: 0 .5rem;
        opacity: .5;
    }

.level-info{
        align-items: baseline;
        display: flex;
        font-size: var(--font-20);
        gap: var(--space-4);
        justify-self: start;
        min-width: 0;
    }

.level-info .dot{
        color: var(--muted);
    }

.level-info .title{
        white-space: nowrap;
    }

.level-info .stats{
        align-items: baseline;
        display: flex;
        gap: 10px;
        margin-left: auto;
        white-space: nowrap;
    }

.center-tools{
        align-items: center;
        display: flex;
        gap: 10px;
        justify-self: center;
    }

.right-tools{
        align-items: center;
        display: flex;
        gap: 6px;
        justify-self: end;
    }

.topbar .ghost{
        border-radius: var(--radius-3);
        display: grid;
        height: var(--topbarH);
        place-items: center;
        width: var(--topbarH);
    }

.topbar .ghost svg{
        height: var(--icon-22);
        width: var(--icon-22);
    }

.level-col > h2{
        text-align: center;
    }

.center-tools select{
        height: var(--topbarH);
    }

.icon-btn.ghost{
        background: #fff;
    }

.icon-btn svg{
        display: block;
        height: var(--icon-22);
        width: var(--icon-22);
    }

.icon-btn{
        align-items: center;
        background: #fff;
        border: 1px solid var(--ink2);
        border-radius: var(--radius-2);
        display: inline-flex;
        gap: 6px;
        height: var(--topbarH);
        justify-content: center;
        padding: var(--space-2) var(--space-6);
        width: var(--topbarH);
        color: #6b7280;
    }

.icon-btn:hover{
        border-color: #cbd5e1;
        color: #374151;
    }

#challengeStars{
        color: #b8b8b8;
        font-weight: 700;
        letter-spacing: 2px;
    }

#challengeStars .filled{
        color: #FFD700;
    }

.total-stars-right{
        font-weight: 700;
    }

/* === Layout & Canvas === */

.layout{
        display: grid;
        gap: var(--space-4);
        grid-template-columns: 1fr;
        padding: var(--space-5);
    }

#board{
        background: #fff;
        border: var(--boardBorder) solid #fff;
        border-radius: var(--radius-5);
        box-shadow: var(--shadow-1);
        display: block;
    }

.code-ui{
        align-items: center;
        display: flex;
        gap: var(--space-7);
        grid-area: ui;
        justify-content: center;
        margin-left: auto;
        margin-right: auto;
        max-width: var(--uiPx);
        padding-left: var(--space-5);
        padding-right: var(--space-5);
        width: 100%;
    }

main.layout{
        align-items: end;
        display: grid;
        flex: 1;
        grid-template-areas: "board"
        "ui"
        "menu";
        grid-template-rows: 1fr auto auto;
        justify-items: center;
        min-height: 0;
    }

.board-wrap{
        margin: 0 auto;
        max-width: 90vw;
        position: relative;
        width: fit-content;
        grid-area: board;
        place-self: center;
    }

/* === Runner Controls === */

.runner{
        align-items: center;
        display: grid;
        gap: var(--space-4);
        grid-auto-rows: var(--icon-42);
        grid-template-columns: repeat(2, var(--btnSmall));
        justify-items: center;
        width: calc(var(--btnSmall, 42px)*2 + var(--space-4));
    }

.runner button{
        background: #fff;
        border: none;
        border-radius: var(--radius-4);
        display: grid;
        height: 100%;
        padding: 0;
        place-items: center;
        width: 100%;
    }

#btnStart{
        background: var(--play);
        grid-column: 1 / span 2;
    }

#btnStep{
        background: var(--stepLight);
        grid-column: 1;
        grid-row: 2;
    }

#btnReset{
        background: var(--resetPink);
        grid-column: 2;
        grid-row: 2;
    }

.runner svg{
        height: 70%;
        width: 70%;
    }

/* === Program UI Bars === */

.program-area{
        align-items: center;
        display: block;
        flex: 1;
        gap: 10px;
    }

.pf-wrap{
        align-items: stretch;
        display: flex;
        gap: var(--space-5);
        overflow-x: auto;
        padding-bottom: var(--space-2);
        white-space: nowrap;
    }

.program-bar{
        align-items: flex-start;
        background: #fff;
        border-radius: var(--radius-4);
        box-shadow: inset 0 0 0 var(--border-2) #eef3f8;
        display: flex;
        flex: 1;
        gap: var(--space-3);
        height: var(--barH);
        min-height: calc(var(--blockH) + 24px);
        min-width: var(--minProgramW);
        overflow-x: auto;
        padding: var(--space-3);
    }

.function-bar{
        background: var(--function-bar-bg);
        box-shadow: inset 0 0 0 2px var(--function-bar-border);
    }

.program-bar .block.if .if-inner.dropzone,
.function-bar .block.if .if-inner.dropzone{
        padding: 4px 0px 4px 2px;
    }

.program-bar .block.if,
.function-bar .block.if{
        height: calc(var(--blockH) + 12px);
        min-height: calc(var(--blockH) + 12px);
        padding-left: 0px;
        gap: 0px;
    }

.program-bar .block.repeat,
.function-bar .block.repeat{
    align-items: center;
    border: 1px solid var(--cheeseInk);
    height: calc(var(--blockH) + 12px);
    min-height: calc(var(--blockH) + 12px);
    min-width: 80px;
    padding-left: 4px;
    padding-right: 32px;
    position: relative;
}

.program-bar .block.repeat .repeat-inner.dropzone,
.function-bar .block.repeat .repeat-inner.dropzone{
    align-items: center;
    min-height: calc(var(--blockH));
    padding-left: 4px;
    padding-right: 4px;
}

#functionBar.locked{
    background: var(--fn-locked-bg);
    border: 2px solid var(--fn-locked-border);
    box-shadow: inset 0 0 0 1px var(--fn-locked-border);
    user-select: none;
}

#functionBar.locked .block{
    background-clip: padding-box;
    cursor: not-allowed;
    border-radius: var(--radius-3);
    font-size: var(--font-26);
    padding: var(--space-2) var(--space-4);
}

#functionBar{
    flex: 0 1 min(100%, var(--fnBarW, 470px));
    max-width: 100%;
    min-width: auto;
    overflow-x: auto; /* keep safe */
    overflow-y: hidden;
    scrollbar-width: none;
}

#functionBar::-webkit-scrollbar{
    display: none;
}

/* Function bar locked: no changing of repeat count or IF selector */
#functionBar.locked .repeat-count,
#functionBar.locked .if-choice,
#functionBar.locked .if-selector {
    pointer-events: none;
    cursor: not-allowed;
}

/* kill any hover wiggle you may have */
#functionBar.locked .repeat-count:hover,
#functionBar.locked .if-choice:hover,
#functionBar.locked .if-selector:hover {
    transform: none;
}

#functionBar.locked .repeat-inner{
    display:flex;
    align-items:center;
    gap:8px;        
    min-height:var(--blockH);
    padding-left: 4px;
    padding-right: 4px;
}

#functionBar.locked .if-inner{
    display:flex;
    align-items:center;
    gap:8px;        
    min-height:var(--blockH);
}

/* === Blocks (Generic) === */

.block .blk-svg{
        display: block;
        height: var(--icon-42);
        width: var(--icon-42);
    }

.block .blk-arrow{
        display: block;
        height: var(--icon-36);
        width: var(--icon-36);
    }

.block.function{
        background: var(--fn-block-bg);
        color: var(--fn-block-fg);
        font-size: 28px;
        font-weight: 800;
        line-height: 1;
    }

.block.function .fn-label{
        display: inline-block;
        transform: translateY(-1px);
    }

.dropzone{
        align-items: center;
        display: flex;
        gap: 8px;
        min-height: var(--blockH);
    }

.block{
        -webkit-user-drag: element;
        align-items: center;
        border-radius: 12px;
        box-sizing: border-box;
        color: #193;
        cursor: grab;
        display: inline-flex;
        font-size: 26px;
        gap: 6px;
        height: var(--blockH);
        justify-content: center;
        min-width: var(--blockW);
        padding: 6px 10px;
        position: relative;
        user-select: none;
    }

.block.current{
        outline: var(--run-outline-width) solid var(--run-outline-color);
        outline-offset: var(--run-outline-offset);
    }

.block.fn-current{
        outline: var(--run-outline-width) solid var(--run-outline-color);
        outline-offset: var(--run-outline-offset);
    }

.block.error{
        outline: 4px solid #ff0000;
    }

.block.dragging{
        cursor: grabbing;
        opacity: 1;
    }

.placeholder{
        background: transparent!important;
        border: var(--border-2) dashed #9bb8d6;
        border-radius: 12px;
        height: var(--blockH);
        min-width: var(--blockW);
        pointer-events: none;
    }

.block[data-type="step"]{
        background: var(--step);
        color: #33040b;
    }

.menu-block.block[data-type="step"]{
        background: var(--step);
        color: #33040b;
    }

.block[data-type="cheese"]{
        background: var(--cheese);
        color: var(--cheeseInk);
    }

.menu-block.block[data-type="cheese"]{
        background: var(--cheese);
        color: var(--cheeseInk);
    }

.block.repeat{
        align-items: stretch;
        background: var(--repeat);
        border: 1px solid var(--cheeseInk);
        color: var(--repeatInk);
    }

.menu-block.block[data-type="repeat"]{
        align-items: stretch;
        background: var(--repeat);
        border: 1px solid var(--cheeseInk);
        color: var(--repeatInk);
    }

.repeat-inner.dropzone{
        align-items: center;
        background: transparent;
        border-radius: 12px;
        display: flex;
        gap: 6px;
        min-height: var(--blockH);
        min-width: var(--blockW);
        padding: 4px;
        user-select: none;
    }

.block-menu .block[data-type="repeat"] .repeat-count{
        cursor: inherit;
  border: var(--border-2) solid #0b2a33;
  border-radius: var(--radius-1);
  bottom: calc(var(--u)*2.5);
  font: 600 var(--font-18)/1 ui-sans-serif;
  padding: calc(var(--u)*0.5) var(--space-4);
  right: var(--space-3);
}

.menu-block.block[data-type="if"]{
        align-items: stretch;
        background: var(--ifBgnd);
        border: 1px solid var(--cheeseInk);
        color: var(--repeatInk);
        display: inline-flex;
        gap: 8px;
        position: relative;
    }

.block.if{
        background: var(--ifBgnd);
        border: 1px solid var(--cheeseInk);
        color: var(--repeatInk);
        gap: 8px;
        position: relative;
        align-items: stretch;
        display: flex;
    }

.if-inner.dropzone{
        align-items: center;
        background: transparent;
        border-radius: 12px;
        display: flex;
        gap: 6px;
        min-height: var(--blockH);
        min-width: var(--blockW);
        padding: 6px;
    }

.block-menu .block[data-type="if"]{
        align-items: stretch;
        display: inline-flex;
        gap: 0;
        height: var(--blockH);
        min-height: var(--blockH);
        min-width: var(--blockW);
        width: auto;
        position: relative;
        padding-left: 0;
    }

.block-menu .block[data-type="if"] .if-inner{
        display: none;  
    }

.block-menu .block[data-type="if"] .if-left{
        padding-left: 0;
        gap: 0;
        align-items: flex-start;
        height: 100%;
        justify-content: center;
        padding: 4px 6px 6px 6px;
        width: auto;
    }

.block-menu .block[data-type="if"] .if-label{
        font-size: var(--font-16);
        text-align: left;
        margin-bottom: calc(var(--u));
        width:auto;
        margin-left: 2px;
  font: 800 var(--font-20)/1 ui-sans-serif;
}

.block-menu .block[data-type="if"] .if-choice{
        cursor: inherit;
        pointer-events: none;
        width: var(--icon-22);
        margin-left: 0;
  border: var(--border-2) solid var(--ifLabel);
  border-radius: var(--radius-1);
}

.menu-block.block{
        align-items: center;
        border-radius: 12px;
        cursor: grab;
        display: inline-flex;
        gap: 8px;
        height: var(--blockH);
        justify-content: center;
        min-width: var(--blockW);
        padding: 6px 10px;
        position: relative;
    }

.blk-svg{
        display: block;
        height: 42px;
        width: 42px;
    }

.blk-arrow{
        display: block;
        height: 36px;
        width: 36px;
    }

.block-menu .block[data-type="repeat"]{
        height: var(--blockH);
        min-height: var(--blockH);
        padding-right: var(--menuRightGap);
        position: relative;
    }

.block[data-type="turnLeft"]{
        background: var(--left);
        color: var(--cheeseInk);
    }

.menu-block.block[data-type="turnLeft"]{
        background: var(--left);
        color: var(--cheeseInk);
    }

.block[data-type="turnRight"]{
        background: var(--right);
        color: var(--cheeseInk);
    }

.menu-block.block[data-type="turnRight"]{
        background: var(--right);
        color: var(--cheeseInk);
    }

.block-menu{
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        margin-left: auto;
        margin-right: auto;
        max-width: var(--uiPx);
        padding-left: 12px;
        padding-right: 12px;
        grid-area: menu;
        margin-bottom: env(safe-area-inset-bottom, 12px);
        width: 100%;   
    }

/* === Repeat Block === */

.repeat-icon{
        height: var(--repeat-icon-menu);
        opacity: 0.9;
        pointer-events: none;
        position: absolute;
        right: var(--space-5);
        top: var(--space-3);
        width: var(--repeat-icon-menu);
    }

.repeat-icon svg{
        display: block;
        height: 100%;
        width: 100%;
    }

.repeat:not(.is-menu) .repeat-icon{
        height: var(--repeat-icon-live);
        right: var(--space-3);
        top: calc(var(--u)*2.5);
        width: var(--repeat-icon-live);
    }

.repeat-count{
        background: #fff;
        border: 2px solid #0b2a33;
        border-radius: 8px;
        bottom: 5px;
        color: #1b1b1b;
        cursor: pointer;
        font: 600 18px/1 ui-sans-serif;
        padding: 1px 6px;
        position: absolute;
        right: 6px;
        user-select: none;
    }

.repeat-outline{
        outline: 0px dashed #b493ff;
    }

.repeat.is-menu .repeat-count{
        border-radius: 7px;
        border-width: 2px;
        bottom: 5px;
        font-size: 12px;
        line-height: 14px;
        padding: 1px 5px;
    }

.repeat.is-menu .repeat-icon{
        right: 7px;
        top: 3px;
    }

.menu-block.block[data-type="repeat"],
.repeat.is-menu{
  padding-right: 55px;     /* same space the menu version used for the icon */
  min-width: var(--blockW);
  height: var(--blockH);
  min-height: var(--blockH);
  position: relative;
}

/* === IF Block === */

.if-left{
        align-items: center;
        display: flex;
        flex-direction: column;
        gap: 0px;
        height: 100%;
        justify-content: center;
        min-width: 40px;
        padding: 6px 6px 6px 8px;
        padding-bottom: 0;
        padding-left: 0px;
        padding-top: 0;
    }

.if-label{
        color: var(--ifLabel);
        font: 800 20px/1 ui-sans-serif, system-ui;
        letter-spacing: .5px;
        margin-bottom: 4px;
        text-align: center;
        width: 100%;
    }

.if-choice{
        aspect-ratio: 1 / 1;
        background: #fff;
        border: 2px solid var(--ifLabel);
        border-radius: 8px;
        box-sizing: border-box;
        cursor: pointer;
        display: inline-grid;
        font-size: 0;
        place-items: center;
        user-select: none;
        width: 26px;
    }

.if-choice .icon{
        display: block;
        height: 20px;
        width: 20px;
    }

.if.is-menu{
    height: var(--blockH);
    min-height: var(--blockH);
    padding-right: 25px;   /* same right reserve as repeat */
    position: relative;
  
}

/* Make IF menu look stick even when cloned (ghost) */
.if.is-menu,
.menu-block.block[data-type="if"]{
    height: var(--blockH);
    min-height: var(--blockH);
    padding-right: 35px;        /* match repeat / repeatUntil menu gap */
    position: relative;
    padding-left: 0px;
}

/* Menu preview behaviour for IF */

.if.is-menu .if-inner{ display: none; }      /* like your .block-menu ‚Ä¶ rule */
.if.is-menu .if-choice{ pointer-events: none; cursor: inherit; }

/* ===== Repeat-Until block (UI only) ===== */

/* Same outer box as repeat */
.program-bar .block.repeat-until,
.function-bar .block.repeat-until{
    align-items: center;
    border: 1px solid var(--cheeseInk);
    height: calc(var(--blockH) + 12px);
    min-height: calc(var(--blockH) + 12px);
    min-width: 80px;
    padding-left: 4px;
    padding-right: 32px;
    position: relative;              /* needed for right-side absolute children */
    background: var(--repeatUntil, #ead8ff); /* pastel purple */
    color: var(--repeatUntilInk, var(--cheeseInk));
}

/* Inner dropzone ‚Äì identical to repeat */
.program-bar .block.repeat-until .repeat-inner.dropzone,
.function-bar .block.repeat-until .repeat-inner.dropzone{
    align-items: center;
    min-height: var(--blockH);
    padding-left: 4px;
    padding-right: 4px;
}

/* Icon position ‚Äì identical to repeat */
.repeat-until .repeat-icon{
    height: 16px;
    opacity: 0.9;
    pointer-events: none;
    position: absolute;
    right: 12px;
    top: 6px;
    width: 16px;
}
.repeat-until:not(.is-menu) .repeat-icon{
    height: 22px;
    right: 8px;
    top: 5px;
    width: 22px;
}

/* Selector sits where repeat-count sits (bottom-right) */
.repeat-until > .until-choice{
    background: #fff;                 /* overridden by color choices when needed */
    border: 2px solid var(--cheeseInk);
    border-radius: 8px;
    box-sizing: border-box;
    display: grid;
    place-items: center;
    position: absolute;
    right: 6px;
    bottom: 5px;
    width: 26px;
    height: 26px;
    cursor: pointer;
    user-select: none;
    font-size: 0;                     /* use the inner .icon sizing */
}


.block.repeat-until{
    align-items: stretch;
    background: var(--repeatUntil, #ead8ff);
    border: 1px solid var(--cheeseInk);
    color: var(--repeatUntilInk, var(--cheeseInk)); 
}


/* Menu preview: small icon, selector disabled */
.block-menu .block[data-type="repeatUntil"]{
    align-items: center;
    background: var(--repeatUntil, #ead8ff);
    border: 1px solid var(--cheeseInk);
    color: var(--repeatUntilInk, var(--cheeseInk));
    display: inline-flex;
    gap: 0;
    position: relative;
    height: var(--blockH);
    min-height: var(--blockH);
    min-width: calc(var(--blockW) + 6px);
    padding-right: 55px;              /* make room for right-side icon */
}
.block-menu .block[data-type="repeatUntil"] .repeat-inner{ display:none; }

/* Disable selector in menu; keep it visible */
.block-menu .block[data-type="repeatUntil"] .until-choice{
    cursor: inherit;
    pointer-events: none;
    width: 22px; height: 22px;
    bottom: 4px;                      /* match the smaller menu height */
}

.repeat-until.is-menu .repeat-icon{
    top: 3px;      
    right: 9px; 
}

/* Locked function bar: disable selector (reuse existing) */
#functionBar.locked .if-choice{ pointer-events:none; cursor:not-allowed; }
#functionBar.locked .if-choice:hover{ transform:none; }


/* === Banners (Win/Delete) === */

.win-banner{
        background: rgba(0,0,0,0.25);
        border-radius: 0;
        display: grid;
        inset: 0;
        place-items: center;
        position: fixed;
        z-index: 10000;
    }

.win-banner .stars{
        font-size: 28px;
        margin-bottom: 6px;
    }

.win-banner .banner-inner{
        background: #FFF7D1;
        border-radius: calc(var(--radius-5) + 2px);
        box-shadow: var(--shadow-2);
        padding: 22px;
        text-align: center;
    }

.win-banner .stars-row{
        align-items: center;
        display: flex;
        gap: 12px;
        justify-content: center;
        margin-bottom: 10px;
    }

.win-banner .win-star polygon{
        stroke: #374151;
        stroke-width: 3;
    }

.win-banner .msg{
        margin-bottom: 10px;
        font-size: 26px;
        font-weight: 800;
        letter-spacing: 0.5px;
        margin: 6px 0 10px 0;
    }

.win-banner .win-actions{
        align-items: center;
        display: flex;
        gap: 16px;
        justify-content: center;
        margin-top: 8px;
    }

.win-banner .win-btn{
        border: 1px solid #cbd5e1;
        border-radius: 20px;
        display: grid;
        font-size: 0;
        height: 80px;
        place-items: center;
        width: 80px;
    }

.win-banner .win-btn svg{
        height: 44px;
        width: 44px;
    }

.win-banner .win-btn.green{
        background: #24d18b;
        border-color: #24d18b;
        color: #fff;
    }

.win-banner .win-btn.red{
        background: #ff6b6b;
        border-color: #ff6b6b;
        color: #fff;
    }

.win-banner .win-btn:hover{
        filter: brightness(0.95);
    }

#deleteBanner{
        background: var(--straw);
        border: 2px solid var(--straw-border);
        border-radius: 12px;
        box-shadow: 0 4px 14px rgba(0,0,0,0.15);
        color: #222;
        display: none;
        left: 50%;
        padding: 12px 16px;
        position: fixed;
        top: var(--space-5);
        transform: translateX(-50%);
        z-index: 1000;
    }

#deleteBanner .row{
        align-items: center;
        display: flex;
        gap: 12px;
    }

#deleteBanner .q{
        font-weight: 600;
        margin-right: 8px;
    }

#deleteBanner .actions{
        display: flex;
        gap: 8px;
        margin-left: auto;
    }

#deleteBanner button{
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: var(--font-18);
        line-height: 1;
        padding: 6px 10px;
    }

/* === Tiles & Mouse Holes === */

.tile.mousehole{
        position: relative;
    }

.tile.mousehole::after{
        background: #000;
        border: var(--mhole-border-width) solid var(--mhole-color, #000);
        border-radius: 50%;
        box-sizing: content-box;
        content: "";
        height: 50%;
        left: 50%;
        position: absolute;
        top: 50%;
        transform: translate(-50%,-50%);
        width: 50%;
    }

.tile.mousehole.color1{
        --mhole-color: var(--mhole-red);
    }

.tile.mousehole.color2{
        --mhole-color: var(--mhole-yellow);
    }

.tile.mousehole.color3{
        --mhole-color: var(--mhole-green);
    }

.tile.mousehole.color4{
        --mhole-color: var(--mhole-blue);
    }



/* === Start Screen & Levels === */

.challenge-row .start-star{
        font-weight: 900;
        line-height: 1;
    }

.challenge-row .start-star.filled{
        color: #FFD000;
        text-shadow: -1px -1px 0 #000,
            0   -1px 0 #000,
            1px -1px 0 #000,
            -1px  0   0 #000,
            1px  0   0 #000,
            -1px  1px 0 #000,
            0    1px 0 #000,
            1px  1px 0 #000;
    }

.challenge-row .start-star.empty{
        color: #b8b8b8;
    }

.challenge-row[disabled]{
        cursor: not-allowed !important;
        filter: grayscale(0.5);
        opacity: 0.45;
    }

.challenge-row.disabled{
        cursor: not-allowed !important;
        filter: grayscale(0.5);
        opacity: 0.45;
    }

/* === Utilities === */

.tiny{
        color: var(--muted);
        font-size: var(--font-12);
        padding: 10px;
        text-align: center;
    }

#debug{
        background: #111;
        border-radius: var(--radius-2);
        bottom: var(--space-4);
        box-shadow: 0 8px 28px rgba(0,0,0,0.35);
        color: #fff;
        font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        max-width: 60ch;
        padding: var(--space-4) var(--space-5);
        position: fixed;
        right: var(--space-4);
        white-space: pre-wrap;
        z-index: 9999;
    }

/* === Other === */

button{
        background: #fff;
        border: 0;
        border-radius: 12px;
        cursor: pointer;
        font-size: 18px;
        padding: 8px 12px;
    }

button.ghost{
        background: #f2f5f9;
    }

#deleteConfirm{
        background: #2e7d32;
        color: #fff;
    }

#deleteCancel{
        background: #c62828;
        color: #fff;
    }

/* === Unparsed/Raw Rules Preserved === */

.challenge-row[disabled]:hover {
    transform: none;

    .path-pill{
    display:inline-block;
    margin:0 8px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid var(--ui-border, #ccc);
    background: var(--ui-bg, #f7f7f7);
    font-size: 0.9rem;
    line-height: 1.2;
    max-width: 28ch;         
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; 
    vertical-align: middle;
    }
  }

/* === Mobile Landscape Overrides (v6.6) === */
@media (orientation: landscape) and (max-height: 480px), 
       (orientation: landscape) and (max-width: 900px) {
    :root{
        --scale: 0.88;            /* scales spacing/fonts/icons via --u */
        --minProgramW: 480px;     /* allow program bar to fit smaller screens */
        --fnBarW: 420px;
        --boardBorder: calc(6px * var(--scale));
        --uiPx: 720px;
    }
    .layout{ 
        gap: var(--space-3); 
        padding: var(--space-4); 
        padding-left: calc(var(--space-5) + env(safe-area-inset-left));
        padding-right: calc(var(--space-5) + env(safe-area-inset-right));
    }
    .pf-wrap{ gap: var(--space-4); }
    .program-bar{ padding: var(--space-2); height: var(--barH); }
    .code-ui{ gap: var(--space-6); }
    .block-menu{ overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .block-menu .block{ touch-action: none; } /* prevent accidental scroll while dragging */
}

/* === Portrait deterrent for phones === */
@media (orientation: portrait) and (max-width: 900px){
  body::before{
    content: "Please rotate your device to landscape to play.";
    position: fixed; inset: 0; z-index: 99999;
    display: grid; place-items: center;
    background: rgba(0,0,0,.75); color: #fff; text-align: center;
    padding: var(--space-8);
    font-size: var(--font-18);
  }
  main.layout, #startScreen{ filter: blur(2px); pointer-events: none; }
}

/* === Safe-area (notches) padding on small screens === */
@media (max-width: 900px){
  .topbar{
    padding-left: calc(var(--space-6) + env(safe-area-inset-left));
    padding-right: calc(var(--space-6) + env(safe-area-inset-right));
  }
}
</style>
</head>

<body>
<header class="topbar">
    <!-- LEFT: level info -->
    <div class="level-info">
        <span class="title" id="levelName">Level 1.3: Sequencing with Loops</span>
        <div class="stats">
        <span class="dot">‚Ä¢</span><span>Target: <strong id="optimalBlocks">2</strong></span>
        <span class="dot">‚Ä¢</span><span>Used: <strong id="yourBlocks">2</strong></span>
        <span class="dot">‚Ä¢</span><span id="challengeStars" title="Best on this challenge">‚òÖ‚òÖ‚òÖ</span>
        </div>
    </div>

    <!-- CENTER: Save controls (Start Screen only) -->
    <div class="center-tools" id="saveControls">
        <button aria-label="Choose save folder" class="icon-btn ghost" id="chooseSaveFolderBtn" title="Choose save folder">

            <!-- Folder icon -->
            <svg aria-hidden="true" viewbox="0 0 24 24">
            <path d="M10 4l2 2h6a2 2 0 0 1 2 2v1H4V6a2 2 0 0 1 2-2h4z" fill="currentColor"></path>
            <path d="M4 9h20v7a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9z" fill="currentColor"></path>
            </svg>
        </button>

        <span class="path-pill" id="chosenFolderBadge" title="No folder chosen">No folder chosen</span>
        <select aria-label="Select player" id="playerSelect" style="min-width:180px;font-size:16px;padding:6px 8px;border-radius:10px;border:1px solid #cbd5e1;">
            <option value="">(choose player)</option>
        </select>

        <button aria-label="New player" class="icon-btn ghost" id="newPlayerBtn" title="New player">
            <!-- Plus icon -->
            <svg aria-hidden="true" viewbox="0 0 24 24">
            <path d="M11 5h2v6h6v2h-6v6h-2v-6H5v-2h6z" fill="currentColor"></path>
            </svg>
        </button>
    </div>

    <!-- RIGHT: totals, delete/mute/home (right-justified) -->
    <div class="right-tools">
        <span id="currentUserBadge" title="Current player">
        <span id="currentUserName">(no player)</span>
        </span>

        <span aria-hidden="true" class="dot-sep">¬∑</span>
        <span class="total-stars-right" id="totalStarsRight" style="align-self:center;padding:0 6px;" title="Your total">0/0 ‚òÖ</span>
        <button class="ghost" id="btnClear" title="Clear program">
        <svg aria-hidden="true" viewbox="0 0 100 100">
            <rect fill="#000" height="10" rx="4" width="48" x="26" y="22"></rect>
            <rect fill="#000" height="52" rx="6" width="44" x="28" y="30"></rect>
            <rect fill="#000" height="6" rx="3" width="20" x="40" y="16"></rect>
        </svg>
        </button>

        <button class="ghost" id="btnDeleteAll" title="Delete all progress">üóëÔ∏è</button>
        <button class="ghost" id="muteToggle" title="Toggle sound">üîä</button>
        <button aria-label="Back to start" class="icon-btn ghost" id="btnBack" title="Home">
        <svg aria-hidden="true" fill="currentColor" viewbox="0 0 24 24">
            <path d="M3 11.5l9-8 9 8v8.5a1 1 0 0 1-1 1h-5.5a1 1 0 0 1-1-1V15a1 1 0 0 0-1-1h-1a1 1 0 0 0-1 1v5.5a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-8.5z"></path>
        </svg>
        </button>
    </div>
</header>

<section class="layout" id="startScreen">
  <div aria-labelledby="deleteBannerQ" aria-modal="true" id="deleteBanner" role="dialog">
    <div class="row">
      <div class="q" id="deleteBannerQ">Delete all progress?</div>
      <div class="actions">
        <button aria-label="Confirm delete (reset all programs and stars)" id="deleteConfirm">‚úì</button>
        <button aria-label="Cancel" id="deleteCancel">‚úó</button>
      </div>
    </div>
  </div>
  <div class="levels-list" id="levelsList" style="display:flex; gap:16px; justify-content:center; flex-wrap:wrap;"></div>
</section>

<main class="layout">
  <section class="board-wrap">
    <canvas height="450" id="board" width="450"></canvas>
    <div class="win-banner" hidden="" id="winBanner">
      <div class="banner-inner">
        <div aria-live="polite" class="stars-row">
          <svg aria-hidden="true" class="win-star" data-index="1" height="100" viewbox="0 0 100 100" width="100"><polygon points="50,5 61,36 94,36 67,55 77,86 50,68 23,86 33,55 6,36 39,36"></polygon></svg>
          <svg aria-hidden="true" class="win-star" data-index="2" height="100" viewbox="0 0 100 100" width="100"><polygon points="50,5 61,36 94,36 67,55 77,86 50,68 23,86 33,55 6,36 39,36"></polygon></svg>
          <svg aria-hidden="true" class="win-star" data-index="3" height="100" viewbox="0 0 100 100" width="100"><polygon points="50,5 61,36 94,36 67,55 77,86 50,68 23,86 33,55 6,36 39,36"></polygon></svg>
        </div>
        <div class="msg" id="winMsg"></div>
        <canvas height="200" id="winMouse" style="display:block; margin: 6px auto 10px auto;" width="200"></canvas>
        <div class="win-actions">
          <button aria-label="Home" class="icon-btn ghost win-btn" id="btnWinHome" title="Home">
            <svg aria-hidden="true" fill="currentColor" viewbox="0 0 24 24"><path d="M3 11.5l9-8 9 8v8.5a1 1 0 0 1-1 1h-5.5a1 1 0 0 1-1-1V15a1 1 0 0 0-1-1h-1a1 1 0 0 0-1 1v5.5a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-8.5z"></path></svg>
          </button>
            <button aria-label="Retry" class="win-btn" id="btnWinRedo" title="Retry"></button>
            <button aria-label="Next or Retry" class="win-btn" id="btnWinNext" title="Next/Retry"></button>
        </div>
      </div>
    </div>
  </section>

  <section class="code-ui">
    <div class="runner">
      <button class="start btn" id="btnStart" title="Start/Pause">‚ñ∂Ô∏è</button>
      <button class="step btn" id="btnStep" title="Step">‚è≠Ô∏è</button>
      <button class="reset btn" id="btnReset" title="Reset">üîÑ</button>
    </div>
    <div class="program-area">
      <div class="pf-wrap" id="pfWrap">
        <!-- Program bar -->
        <div aria-label="Program bar" class="program-bar dropzone" data-max="20" data-root="program" id="programBar"></div>
        <!-- Function bar: only shown when 'function' is in allowedBlocks -->
        <div aria-label="Function bar" class="program-bar function-bar dropzone" data-max="10" data-root="fn" hidden="" id="functionBar"></div>
      </div>
    </div>
  </section>
  <section class="block-menu" id="blockMenu"></section>
</main>

<script>
/* === DPR Canvas Helper (v6.6) === */
function setCanvasBackingScale(canvas){
  try{
    const dpr = Math.max(1, (window.devicePixelRatio || 1));
    const cssW = Math.round(canvas.getBoundingClientRect().width);
    const cssH = Math.round(canvas.getBoundingClientRect().height);
    const needW = Math.max(1, Math.round(cssW * dpr));
    const needH = Math.max(1, Math.round(cssH * dpr));
    if (canvas.width !== needW || canvas.height !== needH){
      const ctx = canvas.getContext('2d');
      // Save existing transform-aware state by resetting width/height (resets transform)
      canvas.width = needW;
      canvas.height = needH;
      // Scale drawing so 1 unit = 1 CSS pixel
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }catch(e){
    console.warn("setCanvasBackingScale:", e);
  }
}



// *********************************************
//
// --- Global toggle for localStorage writes ---
//
// *********************************************

// ENABLE_LOCAL_SAVE
//   true   LOCAL DATA      data saved to browser only
//   false  JSON DATA       data saved to JSON files (in selected directoy) only

const ENABLE_LOCAL_SAVE = false;     




// Hard block of native context menus as early as possible
(function(){
  var handler=function(e){ e.preventDefault(); return false; };
  try{
    window.addEventListener('contextmenu', handler, {capture:true});
    document.addEventListener('contextmenu', handler, {capture:true});
    if(document.body){ document.body.addEventListener('contextmenu', handler, {capture:true}); }
    document.oncontextmenu = handler;
  }catch(_){}
})();

// --- Delete All Progress banner logic ---
function wipeAllProgress(){
    try{
        clearMiuMiuLocal();
        
        // Remove per-challenge programs & stars
        if (Array.isArray(window.CHALLENGES)){
        for (var i=0;i<window.CHALLENGES.length;i++){
            var ch = window.CHALLENGES[i];
            if (ENABLE_LOCAL_SAVE){ try{ localStorage.removeItem(progKey(ch)); }catch(_){} }
            if (ENABLE_LOCAL_SAVE){ try{ localStorage.removeItem(starKey(ch)); }catch(_){} }
        }
        }
        
        // Clear in-memory program if any
        try{ state.program = []; renderProgram && renderProgram(); }catch(_){}
        // Refresh start screen totals
        try{ renderStartScreen && renderStartScreen(); }catch(_){}
        try{ updateTotalsUI && updateTotalsUI(); }catch(_){}
    }catch(e){
        console && console.warn && console.warn("wipeAllProgress()", e);
    }
}

function wireDeleteBanner(){
    var start = document.getElementById('startScreen');
    if (!start) return;
    var btnDeleteAll = document.getElementById('btnDeleteAll');
    var banner = document.getElementById('deleteBanner');
    var btnConfirm = document.getElementById('deleteConfirm');
    var btnCancel = document.getElementById('deleteCancel');

    function showBanner(){ if(banner) banner.style.display='block'; }
    function hideBanner(){ if(banner) banner.style.display='none'; }

    if (btnDeleteAll && !btnDeleteAll.dataset.wired){
        btnDeleteAll.addEventListener('click', function(){ showBanner(); });
        btnDeleteAll.dataset.wired = "1";
    }
    if (btnCancel && !btnCancel.dataset.wired){
        btnCancel.addEventListener('click', function(){ hideBanner(); });
        btnCancel.dataset.wired = "1";
    }
    if (btnConfirm && !btnConfirm.dataset.wired){
        btnConfirm.addEventListener('click', function(){
        wipeAllProgress();
        hideBanner();
        });
        btnConfirm.dataset.wired = "1";
    }
}
// Ensure banner wiring runs when start screen renders
try{ wireDeleteBanner(); }catch(_){}


// --- Top bar mode updater: start vs programming ---
function updateTopBarForScreen(){
try{
    var start = document.getElementById('startScreen');
    var main = document.querySelector('main.layout');
    var onStart = !!(document.getElementById('startScreen') && !document.getElementById('startScreen').hidden);
    var btnAll = document.getElementById('btnDeleteAll');
    var btnTrash = document.getElementById('btnClear');
    const badge = document.getElementById('currentUserBadge');
    if (btnAll)   btnAll.style.display   = onStart ? '' : 'none';
    if (btnTrash) btnTrash.style.display = onStart ? 'none' : '';

    
    if (badge){
        // Hide the player name on start screen OR whenever we're in local-only mode.
        const hideBadge = onStart || ENABLE_LOCAL_SAVE;
        badge.style.display = hideBadge ? 'none' : '';
        // Also hide the dot separator that follows the badge
        const sep = badge.nextElementSibling;
        if (sep && sep.classList && sep.classList.contains('dot-sep')){
            sep.style.display = hideBadge ? 'none' : '';
        }
    }

    if (!onStart && !ENABLE_LOCAL_SAVE) updateCurrentUserUI();

    var _sf = document.getElementById('chooseSaveFolderBtn');
    var _sp = document.getElementById('playerSelect');
    var _sn = document.getElementById('newPlayerBtn');
    var _grp = document.getElementById('saveControls');

    const showSaveCtrls = onStart && !ENABLE_LOCAL_SAVE;
    if (_sf) _sf.style.display = showSaveCtrls ? '' : 'none';
    if (_sp) _sp.style.display = showSaveCtrls ? '' : 'none';
    if (_sn) _sn.style.display = showSaveCtrls ? '' : 'none';
    if (_grp) _grp.style.visibility = showSaveCtrls ? 'visible' : 'hidden';

    try{
        var info = document.querySelector('.level-info');
        var nameEl = document.getElementById('levelName');
        // Determine whether we're on the start screen
        var start = document.getElementById('startScreen');
        var onStart = !!(start && !start.hidden);
        // Header text swap
        if (nameEl){
        if (onStart){
            nameEl.textContent = "MIUMIU: Learn to Code";
        } else {
            // Leave as-is on programming screen; applyLevel() sets it appropriately.
        }
        }
        // Show only the name on start; show metrics on programming screen
        if (info){
        var kids = info.children || [];
        for (var i=0;i<kids.length;i++){
            var k = kids[i];
            if (k.id === 'levelName') continue;
            k.style.display = onStart ? 'none' : '';
        }
        }
    }catch(_){}

    }catch(e){}
}

try{ updateTopBarForScreen(); }catch(_){ }
try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){ }
try{ updateTopBarForScreen(); }catch(_){}

function resolveCurrentPlayerName(){
    const sel = document.getElementById('playerSelect');
    if (sel && sel.selectedIndex >= 0) {
        const opt = sel.options[sel.selectedIndex];
        if (opt && opt.textContent) return opt.textContent.trim();
    }
    if (window.SaveSys && SaveSys.currentPlayerId) return SaveSys.currentPlayerId;
    return "(no player)";
}

function updateCurrentUserUI(){
    const el = document.getElementById('currentUserName');
    if (el) el.textContent = resolveCurrentPlayerName();
}


// Update the header's per-challenge star display (best achieved so far for this challenge)
function updateChallengeStarsUI(){
    try{
        var el = document.getElementById('challengeStars');
        if(!el) return;
        var onStart = !!(document.getElementById('startScreen') && !document.getElementById('startScreen').hidden);
        // Hide on start screen
        el.style.display = onStart ? 'none' : '';
        if(onStart) return;
        // When on programming screen, show based on current challenge
        if(!state || !state.current){ el.textContent = '‚òÜ‚òÜ‚òÜ'; return; }
        var ch = { levelId: state.current.levelId, challengeId: state.current.challengeId };
        var n = getStarsFor(ch) || 0;
        // Render 3 glyphs; fill first n with bright yellow via spans
        var out = '';
        for(var i=1;i<=3;i++){
        if(i<=n) out += '<span class="filled">‚òÖ</span>';
        else out += '‚òÜ';
        if(i<3) out += ' ';
        }
        el.innerHTML = out;
    }catch(_){}
}


// === Multi-challenge helpers ===
function challengeKey(ch){ return ch.levelId + "_" + ch.challengeId; }
function progKey(ch){ return "hc_v2_prog_" + challengeKey(ch); }
function starKey(ch){ return "hc_v2_stars_" + challengeKey(ch); }
function fnProgKey(ch){ return "hc_v2_fn_" + challengeKey(ch); }

function loadProgFor(ch){
    // JSON mode: read from in-memory snapshot
    if (!ENABLE_LOCAL_SAVE && window.SaveSys && SaveSys._snapshot){
        const key = challengeKey(ch);
        const rec = SaveSys._snapshot.challenges && SaveSys._snapshot.challenges[key];
        return (rec && Array.isArray(rec.program)) ? rec.program.slice() : [];
    }
    // Local mode (default)
    try{
        const r = localStorage.getItem(progKey(ch));
        if (r){
        const maybe = JSON.parse(r);
        return Array.isArray(maybe) ? maybe : [];
        }
    }catch(_){}
    return [];
}

function saveProgFor(ch, program){
    if (!ENABLE_LOCAL_SAVE){
        if (window.SaveSys && SaveSys._snapshot){
        const key = challengeKey(ch);
        const rec = SaveSys._snapshot.challenges[key] || (SaveSys._snapshot.challenges[key] = { program:[], fn:[], stars:0 });
        rec.program = Array.isArray(program) ? program.slice() : [];
        try{ updateTotalsUI(); }catch(_){}
        }
        return;
    }
    try{ localStorage.setItem(progKey(ch), JSON.stringify(program)); }catch(_){}
}


function loadFnFor(ch){
    if (!ENABLE_LOCAL_SAVE && window.SaveSys && SaveSys._snapshot){
        const key = challengeKey(ch);
        const rec = SaveSys._snapshot.challenges && SaveSys._snapshot.challenges[key];
        return (rec && Array.isArray(rec.fn)) ? rec.fn.slice() : [];
    }
    try{
        const r = localStorage.getItem(fnProgKey(ch));
        if (r){
        const maybe = JSON.parse(r);
        return Array.isArray(maybe) ? maybe : [];
        }
    }catch(_){}
    return [];
}

function saveFnFor(ch, program){
    if (!ENABLE_LOCAL_SAVE){
        if (window.SaveSys && SaveSys._snapshot){
        const key = challengeKey(ch);
        const rec = SaveSys._snapshot.challenges[key] || (SaveSys._snapshot.challenges[key] = { program:[], fn:[], stars:0 });
        rec.fn = Array.isArray(program) ? program.slice() : [];
        try{ updateTotalsUI(); }catch(_){}
        }
        return;
    }
    try{ localStorage.setItem(fnProgKey(ch), JSON.stringify(program)); }catch(_){}
}


function getStarsFor(ch){
    if (!ENABLE_LOCAL_SAVE && window.SaveSys && SaveSys._snapshot){
        const key = challengeKey(ch);
        const rec = SaveSys._snapshot.challenges && SaveSys._snapshot.challenges[key];
        return rec ? (Number(rec.stars) || 0) : 0;
    }
    try{
        const r = localStorage.getItem(starKey(ch));
        return r ? (Number(r) || 0) : 0;
    }catch(_){ return 0; }
}

function setStarsFor(ch, n){
  try{
    const prev = getStarsFor(ch);
    const m = Math.max(prev, n);
    if (!ENABLE_LOCAL_SAVE){
      if (window.SaveSys && SaveSys._snapshot){
        const key = challengeKey(ch);
        const rec = SaveSys._snapshot.challenges[key] || (SaveSys._snapshot.challenges[key] = { program:[], fn:[], stars:0 });
        rec.stars = m;
        // keep totals fresh for the UI
        if (SaveSys._snapshot.totals) { SaveSys._snapshot.totals.stars = totalAchievedStars(); }
        try{
          updateTotalsUI();
          updateChallengeStarsUI();
          renderStartScreen();
        }catch(_){}
      }
      return;
    }
    localStorage.setItem(starKey(ch), String(m));
  }catch(_){}
}

function totalAvailableStars(){
  return (window.CHALLENGES||[]).length * 3;
}
function totalAchievedStars(){
    if (!ENABLE_LOCAL_SAVE && window.SaveSys && SaveSys._snapshot){
        // Prefer explicit totals if present; else sum the per-challenge stars from snapshot
        const t = SaveSys._snapshot.totals && Number(SaveSys._snapshot.totals.stars);
        if (!isNaN(t)) return t;
        let sum = 0;
        (window.CHALLENGES||[]).forEach(function(ch){
        const key = challengeKey(ch);
        const rec = SaveSys._snapshot.challenges && SaveSys._snapshot.challenges[key];
        sum += rec ? (Number(rec.stars)||0) : 0;
        });
        return sum;
    }
    // Local mode
    let sum = 0;
    (window.CHALLENGES||[]).forEach(function(ch){ sum += getStarsFor(ch); });
    return sum;
}




function updateTotalsUI(){
    var txt = totalAchievedStars() + "/" + totalAvailableStars() + " ‚òÖ";
    var a = document.getElementById("totalStarsStart"); if(a) a.textContent = txt;
    var b = document.getElementById("totalStarsPlay");  if(b) b.textContent = txt;
    var c = document.getElementById("totalStarsRight"); if(c) c.textContent = txt;
}

// Checking valid user
(function () {
    const Guards = {};

    Guards.isFolderChosen = function () {
        if (ENABLE_LOCAL_SAVE) return true;                          // ‚Üê local mode: no folder required
        if (window.SaveSys && ('_dir' in SaveSys)) return !!SaveSys._dir;
        return !!window.__saveFolderChosen__;
    };

    Guards.isUserRegistered = function () {
        if (ENABLE_LOCAL_SAVE) return true;                          // ‚Üê local mode: no player required
        const selectedId =
            (window.SaveSys && SaveSys.currentPlayerId) ||
            (document.getElementById('playerSelect')?.value || '');
        if (!selectedId) return false;

        const usersList =
            (window.SaveSys?.users && Array.isArray(SaveSys.users) && SaveSys.users) ||
            (window.SaveSys?.players && Array.isArray(SaveSys.players) && SaveSys.players) ||
            [];
        return usersList.some(u => (typeof u === 'string')
            ? u === selectedId
            : (u && typeof u === 'object' && ((u.id === selectedId) || (u.name === selectedId))));
    };

    Guards.canPlay = function () {
        if (ENABLE_LOCAL_SAVE) return true;                          // ‚Üê local mode: always unlocked
        return Guards.isFolderChosen() && Guards.isUserRegistered();
    };


  // Expose for other modules
  window.Guards = Guards;
})();

function refreshStartScreenLockState(){
    try{
        const host = document.getElementById("levelsList");
        if (!host) return;
        const locked = !(window.Guards && Guards.canPlay());
        host.querySelectorAll(".challenge-row").forEach(btn=>{
        btn.disabled = locked;
        btn.classList.toggle("disabled", locked);
        });
    }catch(_){}
}

// Build the start screen columns
function renderStartScreen(){
  try{
    var host = document.getElementById("levelsList");
    if(!host) return;
    host.innerHTML = "";
    var groups = {};
    (window.CHALLENGES||[]).forEach(function(ch){
      (groups[ch.levelId] = groups[ch.levelId] || []).push(ch);
    });
    var levelIds = Object.keys(groups).map(Number).sort(function(a,b){return a-b;});
    levelIds.forEach(function(lid){
      var col = document.createElement("div");
      col.className = "level-col";
      col.style.cssText = "background:#fff; border-radius:20px; padding:16px 20px; min-width:260px; box-shadow:0 6px 20px rgba(0,0,0,.08);";


      const LEVEL_COLORS = [
        '#fcead4', // peach
        '#d4ddfa', // indigo
        '#cfe9fa', // sky tint
        '#dad5f7', // violet tint
        '#f0f0c2', // soft yellow
        '#dcfce7', // mint
        '#e0f2fe', // baby blue
        '#fae8ff'  // pink tint
        ];
        const bg = LEVEL_COLORS[(lid - 1) % LEVEL_COLORS.length];
        col.style.background = bg; // override the default white

      var h = document.createElement("h2"); h.textContent = "LEVEL " + lid; h.style.margin="0 0 4px 0"; col.appendChild(h);
      var sub = document.createElement("div"); sub.textContent = ""; sub.style.opacity="0.8"; col.appendChild(sub);
      var ul = document.createElement("div"); ul.style.marginTop="10px"; col.appendChild(ul);
      groups[lid].sort(function(a,b){ return a.challengeId - b.challengeId; }).forEach(function(ch){
        var row = document.createElement("button");

        // Locked if the user or dir not selected
        const locked = !(window.Guards && Guards.canPlay());
        if (locked) {
          row.disabled = true;
          row.classList.add("disabled");
        } else {
          row.disabled = false;
          row.classList.remove("disabled");
        }

        row.type = "button";
        row.className = "challenge-row";
        row.style.cssText = "display:flex; justify-content:space-between; align-items:center; width:100%; background:#f7fafc; border:1px solid #e0e4ea; padding:8px 10px; border-radius:12px; margin:6px 0;";
        var left = document.createElement("span"); left.textContent = "Challenge " + lid + "." + ch.challengeId; row.appendChild(left);
        var stars = getStarsFor(ch);
        
        var right = document.createElement("span");
        right.className = "challenge-stars";
        var _n = Number(stars)||0;
        var _html = "";
        for (var i=1;i<=3;i++){
          if(i<=_n) _html += '<span class="start-star filled">‚òÖ</span>';
          else _html += '<span class="start-star empty">‚òÜ</span>';
          if(i<3) _html += ' ';
        }
        right.innerHTML = _html;
        row.appendChild(right);

        row.addEventListener("click", function(){ startChallenge(lid, ch.challengeId); });
        ul.appendChild(row);
      });
      host.appendChild(col);
    });
    updateTotalsUI();
    refreshStartScreenLockState();
  }catch(e){ showError("renderStartScreen()", e); }
  try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){ }
  try{ wireDeleteBanner && wireDeleteBanner(); }catch(_){}
  try{ wireDeleteBanner && wireDeleteBanner(); }catch(_){}
  try{ updateTopBarForScreen && updateTopBarForScreen(); }catch(_){}
  try{ updateTopBarForScreen && updateTopBarForScreen(); }catch(_){}
}

function startChallenge(levelId, challengeId){
    // Hard gate: don‚Äôt enter the level unless both prerequisites are true
    if (!(window.Guards && Guards.canPlay())) {
        showError("Ensure valid working directory and user");
        // Optional: toast/alert for kids
        try { alert("Zgjidh nj√´ dosje ruajtjeje dhe nj√´ lojtar s√´ pari."); } catch (_){}
        return;
    }
    
    try{
        var ch = (window.CHALLENGES||[]).find(function(c){ return c.levelId===levelId && c.challengeId===challengeId; });
        if(!ch){ showError("Challenge not found: "+levelId+"."+challengeId); return; }
        state.current = { levelId: levelId, challengeId: challengeId };
        applyLevel(ch);

        // Hard reset any in-memory program state so nothing leaks across users/levels
        state.program = [];
        state.functionProgram = [];

        // Enable Function bar when 'function' is in allowedBlocks
        state.functionEnabled = !!(state.level && Array.isArray(state.level.allowedBlocks) &&
        state.level.allowedBlocks.indexOf("function") !== -1);

        state.functionLocked = !!(state.level && state.level.functionLocked);
        state.functionInit = Array.isArray(state.level && state.level.functionContents)
            ? JSON.parse(JSON.stringify(state.level.functionContents)) : [];

        var fnBar = document.getElementById("functionBar");
        if (fnBar) fnBar.hidden = !state.functionEnabled;

        // Load saved program + function
        loadProgram();

        // If no saved function for this challenge, seed it with initial contents
        if (state.functionEnabled && (!state.functionProgram || state.functionProgram.length === 0)) {
        state.functionProgram = JSON.parse(JSON.stringify(state.functionInit));
        try {
            var ch = { levelId: state.current.levelId, challengeId: state.current.challengeId };
            saveFnFor(ch, state.functionProgram);
        } catch(_) {}
        }

        // Load saved program
        state.program = loadProgFor(ch);
        renderProgram(); 
        renderFunctionBar();
        saveProgram();     
        renderButtons();
        try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){} // save() writes with current semantics; kept for compatibility of UI flows

        // Switch views
        var start = document.getElementById("startScreen"); if(start) start.hidden = true;
        var main = document.querySelector("main.layout"); if(main) main.hidden = false;
        try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){}
        try{ updateTopBarForScreen && updateTopBarForScreen(); }catch(_){}
        try{ updateTopBarForScreen && updateTopBarForScreen(); }catch(_){} 
        updateTopBarForScreen(); 
        updateTotalsUI();
        try{ resizeLayout && resizeLayout(); }catch(_){}
        resetToStart();

  }catch(e){ showError("startChallenge()", e); }
}

// -- Safety stubs to avoid undefined errors --
try{
  if(typeof clearErrorHighlight!=='function'){
    function clearErrorHighlight(){ try{ var e=document.querySelector('.block.error'); if(e) e.classList.remove('error'); }catch(_){ } if(typeof state!=='undefined' && state) state.errorId=null; }
  }
  if(typeof setErrorHighlight!=='function'){
    function setErrorHighlight(id){ if(typeof state!=='undefined' && state) state.errorId=id; var el=(state && state.blockEls && state.blockEls[id]) || document.querySelector('.program-bar .block[data-id="'+id+'"]'); if(el){ el.classList.add('error'); el.classList.add('current'); try{ el.scrollIntoView({block:'nearest', inline:'center'});}catch(_){}} }
  }
}catch(_){}

"use strict";

function showError(msg, err){
    try{
        var box=document.getElementById('debug');
        if(!box){ box=document.createElement('div'); box.id='debug'; document.body.appendChild(box); }
        var line=document.createElement('div');
        var ts=new Date().toLocaleTimeString();
        line.textContent='['+ts+'] '+msg+(err?(' ‚Äî '+(err.message||String(err))):'');
        box.appendChild(line);
    }catch(_){}
}
  window.addEventListener('error',function(e){ showError('Unhandled: '+e.message); });

  // === Level ===
  
// === Challenges (multi-grid) ===
window.CHALLENGES = [
    (function(){ var L = {
        levelId: 1,
        challengeId: 1,
        name: "Sequencing",
        grid: { cols: 7, rows: 4 },
        start: { x: 1, y: 1, dir: "E" },     // arrow on the tan tile
        home:  { x: 4, y: 1 },               // house
        obstacles: [
        // row 0 (top): trees + right wall
        {x:0,y:0,type:"tree"},{x:1,y:0,type:"tree"},{x:2,y:0,type:"tree"},{x:3,y:0,type:"tree"},
        {x:4,y:0,type:"wall"},{x:5,y:0,type:"wall"},{x:6,y:0,type:"wall"},
        // row 1
        {x:0,y:1,type:"tree"},
        // row 2: trees + right wall
        {x:0,y:2,type:"tree"},{x:1,y:2,type:"tree"},{x:2,y:2,type:"tree"},{x:3,y:2,type:"tree"},
        {x:4,y:2,type:"wall"},{x:5,y:2,type:"wall"},{x:6,y:2,type:"wall"},
        // row 4 (bottom): water across
        {x:0,y:3,type:"water"},{x:1,y:3,type:"water"},{x:2,y:3,type:"water"},{x:3,y:3,type:"water"},{x:4,y:3,type:"water"},
        {x:5,y:3,type:"water"},{x:6,y:3,type:"water"}
        ],
        cheeses: [],
        optimalBlocks: 3,
        allowedBlocks: ["step"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 1,
        challengeId: 2,
        name: "Sequencing",
        grid: { cols: 7, rows: 5 },
        start: { x: 6, y: 2, dir: "W" },
        home:{x:2,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":0,"y":3,"type":"water"},{"x":1,"y":3,"type":"water"},{"x":2,"y":3,"type":"water"},{"x":3,"y":3,"type":"water"},{"x":4,"y":3,"type":"water"},{"x":5,"y":3,"type":"water"},{"x":6,"y":3,"type":"water"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:4,
        allowedBlocks:["step"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),
  
    (function(){ var L = {
        levelId: 1,
        challengeId: 3,
        name: "Sequencing with Loops",
        grid: { cols: 7, rows: 5 },
        start: { x: 6, y: 2, dir: "W" },
        home:{x:2,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":0,"y":3,"type":"water"},{"x":1,"y":3,"type":"water"},{"x":2,"y":3,"type":"water"},{"x":3,"y":3,"type":"water"},{"x":4,"y":3,"type":"water"},{"x":5,"y":3,"type":"water"},{"x":6,"y":3,"type":"water"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:2,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),
  
    (function(){ var L = {
        levelId: 1,
        challengeId: 4,
        name: "Sequencing with Loops",
        grid: { cols: 5, rows: 5 },
        start: { x: 0, y: 1, dir: "E" },
        home:{x:3,y:1},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":4,"y":2,"type":"tree"},{"x":0,"y":3,"type":"water"},{"x":1,"y":3,"type":"water"},{"x":2,"y":3,"type":"water"},{"x":3,"y":3,"type":"water"},{"x":4,"y":3,"type":"water"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:2,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 1,
        challengeId: 5,
        name: "Sequencing with Loops",
        grid: { cols: 5, rows: 6 },
        start: { x: 2, y: 5, dir: "N" },
        home:{x:2,y:1},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":1,"y":0,"type":"wall"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"tree"},{"x":0,"y":1,"type":"water"},{"x":1,"y":1,"type":"wall"},{"x":3,"y":1,"type":"wall"},{"x":4,"y":1,"type":"tree"},{"x":0,"y":2,"type":"water"},{"x":1,"y":2,"type":"wall"},{"x":3,"y":2,"type":"wall"},{"x":4,"y":2,"type":"wall"},{"x":0,"y":3,"type":"water"},{"x":1,"y":3,"type":"tree"},{"x":0,"y":4,"type":"water"},{"x":1,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":0,"y":5,"type":"water"},{"x":1,"y":5,"type":"tree"},{"x":3,"y":5,"type":"tree"},{"x":4,"y":5,"type":"water"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:2,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 1,
        challengeId: 6,
        name: "Sequencing with Loops",
        grid: { cols: 5, rows: 6 },
        start: { x: 2, y: 1, dir: "S" },
        home:{x:2,y:4},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":1,"y":0,"type":"wall"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"tree"},{"x":0,"y":2,"type":"water"},{"x":1,"y":2,"type":"wall"},{"x":3,"y":2,"type":"wall"},{"x":4,"y":2,"type":"tree"},{"x":0,"y":3,"type":"water"},{"x":1,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":0,"y":4,"type":"water"},{"x":1,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"water"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:2,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
    }; })(),

    (function(){ var L = {
        levelId: 1,
        challengeId: 7,
        name: "Sequencing with Mouse Holes",
        grid: { cols: 5, rows: 5 },
        start: { x: 2, y: 1, dir: "S" },
        home:{x:4,y:2},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":1,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":3,"y":0,"type":"wall"},{"x":0,"y":1,"type":"water"},{"x":1,"y":1,"type":"wall"},{"x":3,"y":1,"type":"wall"},{"x":0,"y":2,"type":"water"},{"x":1,"y":2,"type":"wall"},{"x":3,"y":2,"type":"wall"},{"x":0,"y":3,"type":"water"},{"x":1,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":0,"y":4,"type":"water"},{"x":1,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":4,"y1":0,"x2":2,"y2":4}],
        optimalBlocks:2,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 1,
        challengeId: 8,
        name: "Sequencing with Mouse Holes",
        grid: { cols: 6, rows: 5 },
        start: { x: 0, y: 0, dir: "E" },
        home:{x:4,y:4},
        obstacles:[{"x":0,"y":1,"type":"wall"},{"x":1,"y":1,"type":"wall"},{"x":2,"y":1,"type":"wall"},{"x":3,"y":1,"type":"wall"},{"x":4,"y":1,"type":"wall"},{"x":0,"y":2,"type":"wall"},{"x":0,"y":3,"type":"wall"},{"x":1,"y":3,"type":"wall"},{"x":2,"y":3,"type":"wall"},{"x":3,"y":3,"type":"wall"},{"x":4,"y":3,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":1,"y":4,"type":"wall"},{"x":5,"y":1,"type":"wall"},{"x":5,"y":3,"type":"wall"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":4,"y1":0,"x2":1,"y2":2},{"color":2,"x1":4,"y1":2,"x2":2,"y2":4}],
        optimalBlocks:2,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 1,
        challengeId: 9,
        name: "Sequencing with Mouse Holes",
        grid: { cols: 8, rows: 5 },
        start: { x: 0, y: 0, dir: "E" },
        home:{x:6,y:4},
        obstacles:[],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":2,"y1":0,"x2":1,"y2":1},{"color":2,"x1":3,"y1":1,"x2":2,"y2":2},{"color":3,"x1":4,"y1":2,"x2":3,"y2":3},{"color":4,"x1":5,"y1":3,"x2":4,"y2":4}],
        optimalBlocks:3,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 1,
        challengeId: 10,
        name: "Sequencing with Mouse Holes",
        grid: { cols: 7, rows: 5 },
        start: { x: 0, y: 4, dir: "N" },
        home:{x:6,y:1},
        obstacles:[{"x":1,"y":0,"type":"water"},{"x":3,"y":0,"type":"water"},{"x":5,"y":0,"type":"water"},{"x":1,"y":1,"type":"water"},{"x":3,"y":1,"type":"water"},{"x":5,"y":1,"type":"water"},{"x":1,"y":2,"type":"water"},{"x":3,"y":2,"type":"water"},{"x":5,"y":2,"type":"water"},{"x":1,"y":3,"type":"water"},{"x":3,"y":3,"type":"water"},{"x":5,"y":3,"type":"water"},{"x":1,"y":4,"type":"water"},{"x":3,"y":4,"type":"water"},{"x":5,"y":4,"type":"water"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":0,"y1":1,"x2":2,"y2":4},{"color":2,"x1":2,"y1":1,"x2":4,"y2":4},{"color":3,"x1":4,"y1":1,"x2":6,"y2":4}],
        optimalBlocks:4,
        allowedBlocks:["step","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 1,
        name: "Turning",
        grid: { cols: 4, rows: 4 },
        start: { x: 1, y: 3, dir: "N" },
        home:{x:2,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":2,"y":0,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:3,
        allowedBlocks:["step","turnLeft","turnRight"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 2,
        name: "Turning",
        grid: { cols: 4, rows: 4 },
        start: { x: 2, y: 3, dir: "N" },
        home:{x:1,y:1},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:4,
        allowedBlocks:["step","turnLeft","turnRight"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

   (function(){ var L = {
        levelId: 2,
        challengeId: 3,
        name: "Turning",
        grid: { cols: 6, rows: 4 },
        start: { x: 0, y: 0, dir: "S" },
        home:{x:4,y:2},
        obstacles:[{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["step","turnLeft","turnRight"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 4,
        name: "Turning",
        grid: { cols: 6, rows: 4 },
        start: { x: 4, y: 0, dir: "S" },
        home:{x:1,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"wall"},{"x":3,"y":0,"type":"wall"},{"x":0,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":0,"y":3,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["step","turnLeft","turnRight"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 5,
        name: "Turning",
        grid: { cols: 7, rows: 4 },
        start: { x: 5, y: 3, dir: "N" },
        home:{x:1,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":6,"y":0,"type":"wall"},{"x":0,"y":1,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:4,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 6,
        name: "Turning with Loops",
        grid: { cols: 6, rows: 4 },
        start: { x: 5, y: 2, dir: "W" },
        home:{x:1,y:0},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"wall"},{"x":4,"y":1,"type":"wall"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 7,
        name: "Turning with Loops",
        grid: { cols: 7, rows: 5 },
        start: { x: 6, y: 2, dir: "W" },
        home:{x:1,y:1},
        obstacles:[{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"water"},{"x":4,"y":0,"type":"water"},{"x":5,"y":0,"type":"water"},{"x":6,"y":0,"type":"water"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [{"color":4,"x1":3,"y1":2,"x2":1,"y2":4}],
        optimalBlocks:5,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 8,
        name: "Turning with Loops",
        grid: { cols: 8, rows: 6 },
        start: { x: 3, y: 4, dir: "N" },
        home:{x:1,y:1},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"wall"},{"x":2,"y":1,"type":"wall"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"water"},{"x":6,"y":1,"type":"tree"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":4,"y":2,"type":"tree"},{"x":5,"y":2,"type":"water"},{"x":6,"y":2,"type":"tree"},{"x":0,"y":3,"type":"wall"},{"x":2,"y":3,"type":"wall"},{"x":4,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":2,"y":4,"type":"wall"},{"x":2,"y":5,"type":"wall"}],
        cheeses:[],
        mouseHoles: [{"color":2,"x1":7,"y1":4,"x2":1,"y2":5}],
        optimalBlocks:6,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 9,
        name: "Advanced Turning",
        grid: { cols: 8, rows: 5 },
        start: { x: 4, y: 0, dir: "S" },
        home:{x:6,y:4},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":0,"y":2,"type":"wall"},{"x":1,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":3,"y":2,"type":"wall"},{"x":4,"y":2,"type":"wall"},{"x":5,"y":2,"type":"wall"},{"x":6,"y":2,"type":"wall"},{"x":7,"y":2,"type":"wall"},{"x":3,"y":4,"type":"wall"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":1,"y1":1,"x2":1,"y2":3}],
        optimalBlocks:10,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 2,
        challengeId: 10,
        name: "Advanced Turning",
        grid: { cols: 8, rows: 5 },
        start: { x: 1, y: 4, dir: "E" },
        home:{x:4,y:4},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":3,"y":0,"type":"water"},{"x":5,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"water"},{"x":4,"y":1,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"water"},{"x":4,"y":2,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"water"},{"x":4,"y":3,"type":"tree"},{"x":3,"y":4,"type":"water"}],
        cheeses:[],
        mouseHoles: [{"color":3,"x1":1,"y1":0,"x2":6,"y2":1}],
        optimalBlocks:10,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 1,
        name: "Introducing Cheeses",
        grid: { cols: 6, rows: 4 },
        start: { x: 5, y: 2, dir: "W" },
        home:{x:1,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":0,"y":3,"type":"tree"}],
        cheeses:[{"x":3,"y":2}],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["step","cheese"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 2,
        name: "Introducing Cheeses",
        grid: { cols: 6, rows: 4 },
        start: { x: 5, y: 2, dir: "W" },
        home:{x:0,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"}],
        cheeses:[{"x":1,"y":2},{"x":3,"y":2}],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["step","cheese"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 3,
        name: "Introducing Cheeses",
        grid: { cols: 7, rows: 5 },
        start: { x: 6, y: 2, dir: "N" },
        home:{x:1,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"}],
        cheeses:[{"x":3,"y":2},{"x":4,"y":2}],
        mouseHoles: [],
        optimalBlocks:8,
        allowedBlocks:["step","turnLeft","cheese"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 4,
        name: "Introducing Cheeses",
        grid: { cols: 7, rows: 5 },
        start: { x: 2, y: 2, dir: "W" },
        home:{x:4,y:3},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":1,"y":0,"type":"water"},{"x":2,"y":0,"type":"water"},{"x":3,"y":0,"type":"water"},{"x":4,"y":0,"type":"water"},{"x":5,"y":0,"type":"water"},{"x":6,"y":0,"type":"water"},{"x":0,"y":1,"type":"water"},{"x":6,"y":1,"type":"water"},{"x":0,"y":2,"type":"water"},{"x":6,"y":2,"type":"water"},{"x":0,"y":3,"type":"water"},{"x":6,"y":3,"type":"water"},{"x":0,"y":4,"type":"water"},{"x":1,"y":4,"type":"water"},{"x":2,"y":4,"type":"water"},{"x":3,"y":4,"type":"water"},{"x":4,"y":4,"type":"water"},{"x":5,"y":4,"type":"water"},{"x":6,"y":4,"type":"water"}],
        cheeses:[{"x":2,"y":3},{"x":3,"y":3}],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["step","turnLeft","cheese"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 5,
        name: "Cheeses and Loops",
        grid: { cols: 8, rows: 5 },
        start: { x: 6, y: 0, dir: "S" },
        home:{x:1,y:4},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":0,"y":2,"type":"wall"},{"x":1,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":3,"y":2,"type":"wall"},{"x":4,"y":2,"type":"wall"},{"x":5,"y":2,"type":"wall"},{"x":6,"y":2,"type":"wall"},{"x":7,"y":2,"type":"wall"},{"x":3,"y":4,"type":"water"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"}],
        cheeses:[{"x":2,"y":1}],
        mouseHoles: [{"color":1,"x1":1,"y1":1,"x2":1,"y2":3}],
        optimalBlocks:9,
        allowedBlocks:["step","turnLeft","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 6,
        name: "Cheeses and Loops",
        grid: { cols: 8, rows: 5 },
        start: { x: 3, y: 0, dir: "N" },
        home:{x:1,y:0},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"wall"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"water"},{"x":6,"y":1,"type":"tree"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":4,"y":2,"type":"tree"},{"x":5,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":2,"y":3,"type":"wall"},{"x":2,"y":4,"type":"wall"}],
        cheeses:[{"x":3,"y":3}],
        mouseHoles: [{"color":2,"x1":1,"y1":4,"x2":3,"y2":4}],
        optimalBlocks:10,
        allowedBlocks:["step","turnRight","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 7,
        name: "Cheeses and Loops",
        grid: { cols: 7, rows: 5 },
        start: { x: 6, y: 2, dir: "W" },
        home:{x:1,y:0},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"water"},{"x":4,"y":0,"type":"water"},{"x":5,"y":0,"type":"water"},{"x":6,"y":0,"type":"water"},{"x":0,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[{"x":0,"y":3}],
        mouseHoles: [{"color":2,"x1":0,"y1":2,"x2":1,"y2":4},{"color":4,"x1":3,"y1":2,"x2":4,"y2":3}],
        optimalBlocks:7,
        allowedBlocks:["step","turnLeft","cheese","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

        
    (function(){ var L = {
        levelId: 3,
        challengeId: 8,
        name: "Difficult cheesy challenges",
        grid: { cols: 8, rows: 6 },
        start: { x: 1, y: 0, dir: "S" },
        home:{x:1,y:3},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"water"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"water"},{"x":4,"y":1,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"water"},{"x":4,"y":2,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"water"},{"x":4,"y":3,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"water"},{"x":4,"y":4,"type":"tree"},{"x":2,"y":5,"type":"tree"},{"x":3,"y":5,"type":"water"},{"x":4,"y":5,"type":"tree"}],
        cheeses:[{"x":6,"y":5}],
        mouseHoles: [{"color":3,"x1":6,"y1":0,"x2":1,"y2":2}],
        optimalBlocks:10,
        allowedBlocks:["step","turnLeft","turnRight","cheese","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 9,
        name: "Difficult cheesy challenges",
        grid: { cols: 7, rows: 5 },
        start: { x: 5, y: 0, dir: "W" },
        home:{x:2,y:4},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":6,"y":0,"type":"water"},{"x":0,"y":1,"type":"water"},{"x":1,"y":1,"type":"water"},{"x":2,"y":1,"type":"water"},{"x":3,"y":1,"type":"water"},{"x":4,"y":1,"type":"water"},{"x":5,"y":1,"type":"water"},{"x":6,"y":1,"type":"water"},{"x":0,"y":2,"type":"water"},{"x":5,"y":2,"type":"water"},{"x":6,"y":2,"type":"water"},{"x":0,"y":3,"type":"water"},{"x":1,"y":3,"type":"water"},{"x":2,"y":3,"type":"water"},{"x":3,"y":3,"type":"water"},{"x":4,"y":3,"type":"water"},{"x":5,"y":3,"type":"water"},{"x":6,"y":3,"type":"water"},{"x":0,"y":4,"type":"water"},{"x":6,"y":4,"type":"water"}],
        cheeses:[{"x":3,"y":0},{"x":3,"y":2}],
        mouseHoles: [{"color":2,"x1":1,"y1":0,"x2":4,"y2":2},{"color":4,"x1":1,"y1":2,"x2":5,"y2":4}],
        optimalBlocks:8,
        allowedBlocks:["step","cheese","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 3,
        challengeId: 10,
        name: "Difficult cheesy challenges",
        grid: { cols: 7, rows: 5 },
        start: { x: 0, y: 4, dir: "N" },
        home:{x:6,y:0},
        obstacles:[{"x":1,"y":0,"type":"water"},{"x":3,"y":0,"type":"water"},{"x":5,"y":0,"type":"water"},{"x":1,"y":1,"type":"water"},{"x":3,"y":1,"type":"water"},{"x":5,"y":1,"type":"water"},{"x":1,"y":2,"type":"water"},{"x":5,"y":2,"type":"water"},{"x":1,"y":3,"type":"water"},{"x":3,"y":3,"type":"water"},{"x":5,"y":3,"type":"water"},{"x":1,"y":4,"type":"water"},{"x":3,"y":4,"type":"water"},{"x":5,"y":4,"type":"water"}],
        cheeses:[{"x":3,"y":2}],
        mouseHoles: [{"color":1,"x1":0,"y1":0,"x2":2,"y2":4},{"color":3,"x1":4,"y1":0,"x2":6,"y2":4}],
        optimalBlocks:9,
        allowedBlocks:["step","turnLeft","turnRight","cheese","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 1,
        name: "Advanced Loops",
        grid: { cols: 7, rows: 5 },
        start: { x: 5, y: 2, dir: "W" },
        home:{x:1,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[{"x":2,"y":2},{"x":3,"y":2},{"x":4,"y":2}],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["step","cheese"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 2,
        name: "Advanced Loops",
        grid: { cols: 7, rows: 5 },
        start: { x: 5, y: 2, dir: "W" },
        home:{x:1,y:2},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":1,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":6,"y":0,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":1,"y":4,"type":"wall"},{"x":2,"y":4,"type":"wall"},{"x":3,"y":4,"type":"wall"},{"x":4,"y":4,"type":"wall"},{"x":5,"y":4,"type":"wall"},{"x":6,"y":4,"type":"wall"}],
        cheeses:[{"x":2,"y":2},{"x":3,"y":2},{"x":4,"y":2}],
        mouseHoles: [],
        optimalBlocks:4,
        allowedBlocks:["step","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 3,
        name: "Advanced Loops",
        grid: { cols: 9, rows: 5 },
        start: { x: 0, y: 2, dir: "E" },
        home:{x:7,y:2},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":1,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":6,"y":0,"type":"wall"},{"x":7,"y":0,"type":"wall"},{"x":8,"y":0,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":1,"y":4,"type":"wall"},{"x":2,"y":4,"type":"wall"},{"x":3,"y":4,"type":"wall"},{"x":4,"y":4,"type":"wall"},{"x":5,"y":4,"type":"wall"},{"x":6,"y":4,"type":"wall"},{"x":7,"y":4,"type":"wall"},{"x":8,"y":4,"type":"wall"}],
        cheeses:[{"x":2,"y":2},{"x":4,"y":2},{"x":6,"y":2}],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["step","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 4,
        name: "Advanced Loops",
        grid: { cols: 5, rows: 5 },
        start: { x: 0, y: 0, dir: "E" },
        home:{x:4,y:4},
        obstacles:[{"x":0,"y":1,"type":"wall"},{"x":1,"y":1,"type":"wall"},{"x":2,"y":1,"type":"wall"},{"x":3,"y":1,"type":"wall"},{"x":4,"y":1,"type":"wall"},{"x":0,"y":3,"type":"wall"},{"x":1,"y":3,"type":"wall"},{"x":2,"y":3,"type":"wall"},{"x":3,"y":3,"type":"wall"},{"x":4,"y":3,"type":"wall"}],
        cheeses:[{"x":2,"y":0},{"x":2,"y":2},{"x":2,"y":4}],
        mouseHoles: [{"color":1,"x1":4,"y1":0,"x2":0,"y2":2},{"color":2,"x1":4,"y1":2,"x2":0,"y2":4}],
        optimalBlocks:6,
        allowedBlocks:["step","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 5,
        name: "Advanced Loops",
        grid: { cols: 7, rows: 4 },
        start: { x: 0, y: 3, dir: "N" },
        home:{x:6,y:0},
        obstacles:[{"x":1,"y":0,"type":"water"},{"x":3,"y":0,"type":"water"},{"x":5,"y":0,"type":"water"},{"x":1,"y":1,"type":"water"},{"x":3,"y":1,"type":"water"},{"x":5,"y":1,"type":"water"},{"x":1,"y":2,"type":"water"},{"x":3,"y":2,"type":"water"},{"x":5,"y":2,"type":"water"},{"x":1,"y":3,"type":"water"},{"x":3,"y":3,"type":"water"},{"x":5,"y":3,"type":"water"}],
        cheeses:[{"x":0,"y":1},{"x":2,"y":1},{"x":4,"y":1},{"x":6,"y":1},{"x":0,"y":2},{"x":2,"y":2},{"x":4,"y":2},{"x":6,"y":2}],
        mouseHoles: [{"color":1,"x1":0,"y1":0,"x2":2,"y2":3},{"color":2,"x1":2,"y1":0,"x2":4,"y2":3},{"color":3,"x1":4,"y1":0,"x2":6,"y2":3}],
        optimalBlocks:6,
        allowedBlocks:["step","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 6,
        name: "Advanced Loops",
        grid: { cols: 8, rows: 5 },
        start: { x: 7, y: 4, dir: "N" },
        home:{x:1,y:0},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":2,"y":1,"type":"wall"},{"x":0,"y":3,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"wall"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"water"},{"x":6,"y":1,"type":"tree"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":4,"y":2,"type":"tree"},{"x":5,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":2,"y":3,"type":"wall"},{"x":2,"y":4,"type":"wall"}],
        cheeses:[{"x":1,"y":1},{"x":3,"y":1},{"x":7,"y":1},{"x":1,"y":3},{"x":3,"y":3},{"x":7,"y":3}],
        mouseHoles: [{"color":2,"x1":3,"y1":0,"x2":1,"y2":4},{"color":4,"x1":7,"y1":0,"x2":3,"y2":4}],
        optimalBlocks:4,
        allowedBlocks:["step","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 7,
        name: "Advanced Loops with Turning",
        grid: { cols: 5, rows: 5 },
        start: { x: 1, y: 3, dir: "W" },
        home:{x:3,y:3},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":1,"y":0,"type":"water"},{"x":2,"y":0,"type":"water"},{"x":3,"y":0,"type":"water"},{"x":4,"y":0,"type":"water"},{"x":0,"y":1,"type":"water"},{"x":4,"y":1,"type":"water"},{"x":0,"y":2,"type":"water"},{"x":2,"y":2,"type":"tree"},{"x":4,"y":2,"type":"water"},{"x":0,"y":3,"type":"water"},{"x":2,"y":3,"type":"tree"},{"x":4,"y":3,"type":"water"},{"x":0,"y":4,"type":"water"},{"x":1,"y":4,"type":"water"},{"x":2,"y":4,"type":"water"},{"x":3,"y":4,"type":"water"},{"x":4,"y":4,"type":"water"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:4,
        allowedBlocks:["step","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 8,
        name: "Advanced Loops with Turning",
        grid: { cols: 5, rows: 5 },
        start: { x: 0, y: 0, dir: "E" },
        home:{x:4,y:4},
        obstacles:[{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":4,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 9,
        name: "Advanced Loops with Turning",
        grid: { cols: 9, rows: 5 },
        start: { x: 8, y: 4, dir: "N" },
        home:{x:0,y:0},
        obstacles:[{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":8,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":7,"y":1,"type":"tree"},{"x":8,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":7,"y":2,"type":"tree"},{"x":8,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"},{"x":7,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:6,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 4,
        challengeId: 10,
        name: "Advanced Loops with Turning",
        grid: { cols: 9, rows: 5 },
        start: { x: 0, y: 4, dir: "E" },
        home:{x:8,y:0},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":1,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":0,"y":1,"type":"wall"},{"x":1,"y":1,"type":"wall"},{"x":3,"y":1,"type":"wall"},{"x":4,"y":1,"type":"wall"},{"x":5,"y":1,"type":"wall"},{"x":7,"y":1,"type":"wall"},{"x":8,"y":1,"type":"wall"},{"x":3,"y":2,"type":"wall"},{"x":7,"y":2,"type":"wall"},{"x":8,"y":2,"type":"wall"},{"x":1,"y":3,"type":"wall"},{"x":2,"y":3,"type":"wall"},{"x":3,"y":3,"type":"wall"},{"x":5,"y":3,"type":"wall"},{"x":6,"y":3,"type":"wall"},{"x":7,"y":3,"type":"wall"},{"x":8,"y":3,"type":"wall"},{"x":1,"y":4,"type":"wall"},{"x":2,"y":4,"type":"wall"},{"x":3,"y":4,"type":"wall"},{"x":5,"y":4,"type":"wall"},{"x":6,"y":4,"type":"wall"},{"x":7,"y":4,"type":"wall"},{"x":8,"y":4,"type":"wall"}],
        cheeses:[],
        mouseHoles: [{"color":2,"x1":4,"y1":0,"x2":4,"y2":4}],
        optimalBlocks:7,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),


    (function(){ var L = {
        levelId: 5,
        challengeId: 1,
        name: "Nested Loops",
        grid: { cols: 7, rows: 6 },
        start: { x: 1, y: 0, dir: "W" },
        home:{x:5,y:4},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":6,"y":0,"type":"wall"},{"x":0,"y":1,"type":"wall"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"water"},{"x":4,"y":1,"type":"tree"},{"x":6,"y":1,"type":"wall"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"water"},{"x":4,"y":2,"type":"tree"},{"x":6,"y":2,"type":"wall"},{"x":0,"y":3,"type":"wall"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":6,"y":3,"type":"wall"},{"x":0,"y":5,"type":"wall"},{"x":6,"y":5,"type":"wall"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:4,
        allowedBlocks:["step","turnLeft","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 2,
        name: "Nested Loops",
        grid: { cols: 8, rows: 6 },
        start: { x: 6, y: 5, dir: "S" },
        home:{x:6,y:0},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":7,"y":0,"type":"wall"},{"x":0,"y":1,"type":"wall"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"wall"},{"x":7,"y":1,"type":"wall"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"water"},{"x":4,"y":2,"type":"water"},{"x":5,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":0,"y":3,"type":"wall"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"water"},{"x":4,"y":3,"type":"water"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":0,"y":4,"type":"wall"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"wall"},{"x":7,"y":4,"type":"wall"},{"x":7,"y":5,"type":"wall"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:4,
        allowedBlocks:["step","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 3,
        name: "Nested Loops",
        grid: { cols: 8, rows: 5 },
        start: { x: 0, y: 4, dir: "E" },
        home:{x:7,y:1},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":5,"y":2,"type":"tree"},{"x":7,"y":2,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":7,"y":3,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":7,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":1,"y1":1,"x2":2,"y2":4},{"color":2,"x1":3,"y1":1,"x2":4,"y2":4},{"color":3,"x1":5,"y1":1,"x2":6,"y2":4}],
        optimalBlocks:6,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 4,
        name: "Nested Loops",
        grid: { cols: 7, rows: 5 },
        start: { x: 0, y: 0, dir: "S" },
        home:{x:4,y:1},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":3,"y":0,"type":"wall"},{"x":1,"y":1,"type":"tree"},{"x":3,"y":1,"type":"wall"},{"x":5,"y":1,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":3,"y":2,"type":"wall"},{"x":5,"y":2,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":3,"y":3,"type":"wall"},{"x":5,"y":3,"type":"tree"},{"x":3,"y":4,"type":"wall"},{"x":5,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":2,"y1":3,"x2":6,"y2":4}],
        optimalBlocks:8,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 5,
        name: "Nested Loops",
        grid: { cols: 6, rows: 5 },
        start: { x: 1, y: 0, dir: "S" },
        home:{x:4,y:3},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":0,"y":1,"type":"wall"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":5,"y":1,"type":"wall"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":5,"y":2,"type":"wall"},{"x":0,"y":3,"type":"wall"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":5,"y":3,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":5,"y":4,"type":"wall"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 6,
        name: "Nested Loops",
        grid: { cols: 11, rows: 5 },
        start: { x: 1, y: 0, dir: "S" },
        home:{x:6,y:1},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":7,"y":0,"type":"tree"},{"x":8,"y":0,"type":"tree"},{"x":10,"y":0,"type":"wall"},{"x":0,"y":1,"type":"wall"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":5,"y":1,"type":"wall"},{"x":7,"y":1,"type":"tree"},{"x":8,"y":1,"type":"tree"},{"x":10,"y":1,"type":"wall"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":5,"y":2,"type":"wall"},{"x":7,"y":2,"type":"tree"},{"x":8,"y":2,"type":"tree"},{"x":10,"y":2,"type":"wall"},{"x":0,"y":3,"type":"wall"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":5,"y":3,"type":"wall"},{"x":7,"y":3,"type":"tree"},{"x":8,"y":3,"type":"tree"},{"x":10,"y":3,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":5,"y":4,"type":"wall"},{"x":10,"y":4,"type":"wall"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":4,"y1":3,"x2":9,"y2":4}],
        optimalBlocks:5,
        allowedBlocks:["step","turnLeft","turnRight","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 7,
        name: "Nested Loops with Cheeses",
        grid: { cols: 8, rows: 5 },
        start: { x: 7, y: 4, dir: "N" },
        home:{x:1,y:0},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"wall"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"water"},{"x":6,"y":1,"type":"tree"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":4,"y":2,"type":"tree"},{"x":5,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":2,"y":3,"type":"wall"},{"x":2,"y":4,"type":"wall"}],
        cheeses:[{"x":1,"y":2},{"x":3,"y":2},{"x":7,"y":2},{"x":1,"y":3},{"x":3,"y":3},{"x":7,"y":3}],
        mouseHoles: [{"color":2,"x1":3,"y1":0,"x2":1,"y2":4},{"color":4,"x1":7,"y1":0,"x2":3,"y2":4}],
        optimalBlocks:6,
        allowedBlocks:["step","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 8,
        name: "Nested Loops with Cheeses",
        grid: { cols: 9, rows: 5 },
        start: { x: 1, y: 1, dir: "E" },
        home:{x:7,y:3},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":1,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":6,"y":0,"type":"wall"},{"x":7,"y":0,"type":"wall"},{"x":8,"y":0,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":1,"y":4,"type":"wall"},{"x":2,"y":4,"type":"wall"},{"x":3,"y":4,"type":"wall"},{"x":4,"y":4,"type":"wall"},{"x":5,"y":4,"type":"wall"},{"x":6,"y":4,"type":"wall"},{"x":7,"y":4,"type":"wall"},{"x":8,"y":4,"type":"wall"}],
        cheeses:[{"x":3,"y":1},{"x":5,"y":1},{"x":3,"y":2},{"x":5,"y":2},{"x":3,"y":3},{"x":5,"y":3}],
        mouseHoles: [{"color":2,"x1":7,"y1":1,"x2":1,"y2":2},{"color":4,"x1":7,"y1":2,"x2":1,"y2":3}],
        optimalBlocks:7,
        allowedBlocks:["step","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 9,
        name: "Nested Loops with Cheeses",
        grid: { cols: 10, rows: 5 },
        start: { x: 0, y: 4, dir: "E" },
        home:{x:8,y:3},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":9,"y":0,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":9,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":4,"y":2,"type":"tree"},{"x":5,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":7,"y":2,"type":"tree"},{"x":8,"y":2,"type":"tree"},{"x":9,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":7,"y":3,"type":"tree"},{"x":9,"y":3,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":9,"y":4,"type":"tree"}],
        cheeses:[{"x":1,"y":1},{"x":2,"y":1},{"x":3,"y":1},{"x":6,"y":1},{"x":7,"y":1},{"x":8,"y":1},{"x":1,"y":4},{"x":2,"y":4},{"x":3,"y":4},{"x":6,"y":4},{"x":7,"y":4},{"x":8,"y":4}],
        mouseHoles: [{"color":2,"x1":5,"y1":1,"x2":3,"y2":3},{"color":3,"x1":8,"y1":0,"x2":0,"y2":1},{"color":4,"x1":3,"y1":0,"x2":5,"y2":4}],
        optimalBlocks:7,
        allowedBlocks:["step","turnLeft","turnRight","cheese","repeat"]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,
        grid: L.grid, start: L.start, home: L.home,
        obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 5,
        challengeId: 10,
        name: "Nested Loops with Cheeses",
        grid: { cols: 11, rows: 5 },
        start: { x: 6, y: 4, dir: "E" },
        home:{x:4,y:2},
        obstacles:[{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":8,"y":0,"type":"tree"},{"x":9,"y":0,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":7,"y":1,"type":"tree"},{"x":8,"y":1,"type":"tree"},{"x":9,"y":1,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":5,"y":2,"type":"water"},{"x":9,"y":2,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":7,"y":3,"type":"tree"},{"x":8,"y":3,"type":"tree"},{"x":9,"y":3,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"}],
        cheeses:[{"x":3,"y":2},{"x":7,"y":2}],
        mouseHoles: [{"color":1,"x1":4,"y1":0,"x2":6,"y2":2},{"color":2,"x1":2,"y1":2,"x2":0,"y2":4},{"color":4,"x1":10,"y1":0,"x2":8,"y2":2}],
        optimalBlocks:8,
        allowedBlocks:["step","turnLeft","turnRight","cheese","repeat"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),

    (function(){ var L = {
        levelId: 6,
        challengeId: 1,
        name: "Introduction Functions",
        grid: { cols: 6, rows: 4 },
        start: { x: 5, y: 2, dir: "W" },
        home:{x:2,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"}],
        cheeses:[{"x":3,"y":2}],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["step", "function"],
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"cheese"}]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 6,
        challengeId: 2,
        name: "Introduction Functions",
        grid: { cols: 6, rows: 4 },
        start: { x: 0, y: 2, dir: "E" },
        home:{x:5,y:2},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":5,"y":0,"type":"wall"},{"x":3,"y":1,"type":"tree"},{"x":5,"y":1,"type":"wall"},{"x":0,"y":3,"type":"tree"},{"x":5,"y":3,"type":"wall"}],
        cheeses:[{"x":3,"y":2}],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["step","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"step"},{"type":"cheese"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 6,
        challengeId: 3,
        name: "Introduction Functions",
        grid: { cols: 8, rows: 4 },
        start: { x: 0, y: 2, dir: "E" },
        home:{x:6,y:2},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":7,"y":0,"type":"tree"},{"x":2,"y":1,"type":"wall"},{"x":4,"y":1,"type":"wall"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"wall"},{"x":4,"y":3,"type":"wall"}],
        cheeses:[{"x":2,"y":2},{"x":4,"y":2}],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["step","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"cheese"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 6,
        challengeId: 4,
        name: "Introduction Functions",
        grid: { cols: 8, rows: 5 },
        start: { x: 0, y: 2, dir: "E" },
        home:{x:6,y:2},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"water"},{"x":4,"y":0,"type":"water"},{"x":5,"y":0,"type":"water"},{"x":6,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"water"},{"x":4,"y":4,"type":"water"},{"x":5,"y":4,"type":"water"},{"x":6,"y":4,"type":"tree"},{"x":7,"y":4,"type":"tree"}],
        cheeses:[{"x":1,"y":2},{"x":2,"y":2},{"x":3,"y":2},{"x":5,"y":2}],
        mouseHoles: [],
        optimalBlocks:8,
        allowedBlocks:["step","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"cheese"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 6,
        challengeId: 5,
        name: "Introduction Functions",
        grid: { cols: 7, rows: 5 },
        start: { x: 5, y: 1, dir: "W" },
        home:{x:1,y:3},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":4,"y":2,"type":"tree"},{"x":5,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[{"x":3,"y":1},{"x":3,"y":3}],
        mouseHoles: [{"color":1,"x1":1,"y1":1,"x2":5,"y2":3}],
        optimalBlocks:7,
        allowedBlocks:["step","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"cheese"},{"type":"step"},{"type":"step"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),


    (function(){ var L = {
        levelId: 6,
        challengeId: 6,
        name: "Introduction Functions",
        grid: { cols: 7, rows: 5 },
        start: { x: 1, y: 0, dir: "S" },
        home:{x:5,y:3},
        obstacles:[{"x":0,"y":0,"type":"wall"},{"x":2,"y":0,"type":"wall"},{"x":4,"y":0,"type":"wall"},{"x":6,"y":0,"type":"wall"},{"x":0,"y":1,"type":"wall"},{"x":2,"y":1,"type":"wall"},{"x":4,"y":1,"type":"wall"},{"x":6,"y":1,"type":"wall"},{"x":0,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":4,"y":2,"type":"wall"},{"x":6,"y":2,"type":"wall"},{"x":0,"y":3,"type":"wall"},{"x":2,"y":3,"type":"wall"},{"x":4,"y":3,"type":"wall"},{"x":6,"y":3,"type":"wall"},{"x":0,"y":4,"type":"wall"},{"x":2,"y":4,"type":"wall"},{"x":4,"y":4,"type":"wall"},{"x":6,"y":4,"type":"wall"}],
        cheeses:[{"x":1,"y":2},{"x":3,"y":2},{"x":5,"y":2}],
        mouseHoles: [{"color":1,"x1":3,"y1":0,"x2":1,"y2":3},{"color":2,"x1":5,"y1":0,"x2":3,"y2":3}],
        optimalBlocks:7,
        allowedBlocks:["step","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"cheese"},{"type":"step"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),
        
    (function(){ var L = {
        levelId: 6,
        challengeId: 7,
        name: "Functions with Loops",
        grid: { cols: 7, rows: 5 },
        start: { x: 1, y: 0, dir: "S" },
        home:{x:5,y:3},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":2,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":4,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[{"x":1,"y":2},{"x":3,"y":2},{"x":5,"y":2}],
        mouseHoles: [{"color":1,"x1":3,"y1":0,"x2":1,"y2":3},{"color":2,"x1":5,"y1":0,"x2":3,"y2":3}],
        optimalBlocks:6,
        allowedBlocks:["step","repeat","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"cheese"},{"type":"step"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 6,
        challengeId: 8,
        name: "Functions with Loops",
        grid: { cols: 8, rows: 5 },
        start: { x: 7, y: 0, dir: "W" },
        home:{x:0,y:4},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":1,"y":0,"type":"water"},{"x":2,"y":0,"type":"water"},{"x":3,"y":0,"type":"water"},{"x":0,"y":1,"type":"water"},{"x":1,"y":1,"type":"water"},{"x":2,"y":1,"type":"water"},{"x":7,"y":1,"type":"water"},{"x":0,"y":2,"type":"water"},{"x":1,"y":2,"type":"water"},{"x":6,"y":2,"type":"water"},{"x":7,"y":2,"type":"water"},{"x":0,"y":3,"type":"water"},{"x":5,"y":3,"type":"water"},{"x":6,"y":3,"type":"water"},{"x":7,"y":3,"type":"water"},{"x":4,"y":4,"type":"water"},{"x":5,"y":4,"type":"water"},{"x":6,"y":4,"type":"water"},{"x":7,"y":4,"type":"water"}],
        cheeses:[{"x":5,"y":0},{"x":6,"y":0},{"x":4,"y":1},{"x":5,"y":1},{"x":3,"y":2},{"x":4,"y":2},{"x":2,"y":3},{"x":3,"y":3},{"x":1,"y":4},{"x":2,"y":4}],
        mouseHoles: [{"color":1,"x1":4,"y1":0,"x2":6,"y2":1},{"color":2,"x1":3,"y1":1,"x2":5,"y2":2},{"color":3,"x1":2,"y1":2,"x2":4,"y2":3},{"color":4,"x1":1,"y1":3,"x2":3,"y2":4}],
        optimalBlocks:7,
        allowedBlocks:["step","repeat","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"cheese"},{"type":"step"},{"type":"cheese"},{"type":"step"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

     (function(){ var L = {
        levelId: 6,
        challengeId: 9,
        name: "Introduction Functions",
        grid: { cols: 7, rows: 5 },
        start: { x: 3, y: 0, dir: "S" },
        home:{x:3,y:4},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":0,"type":"wall"},{"x":5,"y":0,"type":"wall"},{"x":6,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":5,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"wall"},{"x":5,"y":4,"type":"wall"},{"x":6,"y":4,"type":"tree"}],
        cheeses:[{"x":3,"y":1},{"x":3,"y":2},{"x":3,"y":3}],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["step","repeat","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"cheese"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 6,
        challengeId: 10,
        name: "Functions with Loops",
        grid: { cols: 8, rows: 5 },
        start: { x: 5, y: 0, dir: "W" },
        home:{x:2,y:4},
        obstacles:[{"x":6,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":7,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":7,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":7,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"}],
        cheeses:[{"x":1,"y":0},{"x":3,"y":0},{"x":2,"y":2},{"x":4,"y":2},{"x":3,"y":4},{"x":5,"y":4}],
        mouseHoles: [{"color":1,"x1":0,"y1":0,"x2":6,"y2":2},{"color":4,"x1":1,"y1":2,"x2":7,"y2":4}],
        optimalBlocks:7,
        allowedBlocks:["step","repeat","function"]        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"cheese"}]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 1,
        name: "Functions with Turning",
        grid: { cols: 6, rows: 4 },
        start: { x: 1, y: 3, dir: "E" },
        home:{x:1,y:0},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":2,"y":1,"type":"wall"},{"x":3,"y":1,"type":"wall"},{"x":5,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":2,"y":2,"type":"wall"},{"x":3,"y":2,"type":"wall"},{"x":5,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:6,
        allowedBlocks:["repeat","function"],
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"step"},{"type":"turnLeft"}]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 2,
        name: "Functions with Turning",
        grid: { cols: 6, rows: 4 },
        start: { x: 1, y: 3, dir: "E" },
        home:{x:1,y:0},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":2,"y":1,"type":"water"},{"x":3,"y":1,"type":"water"},{"x":5,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":2,"y":2,"type":"water"},{"x":3,"y":2,"type":"water"},{"x":5,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"}],
        cheeses:[{"x":3,"y":0},{"x":4,"y":2},{"x":2,"y":3}],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["cheese","repeat","function"],
        functionLocked:false,
       functionContents:[{"type":"step"},{"type":"step"},{"type":"step"},{"type":"turnLeft"}]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),


    (function(){ var L = {
        levelId: 7,
        challengeId: 3,
        name: "Functions with Turning",
        grid: { cols: 5, rows: 5 },
        start: { x: 1, y: 3, dir: "N" },
        home:{x:3,y:3},
        obstacles:[{"x":0,"y":0,"type":"water"},{"x":1,"y":0,"type":"water"},{"x":2,"y":0,"type":"water"},{"x":3,"y":0,"type":"water"},{"x":4,"y":0,"type":"water"},{"x":0,"y":1,"type":"water"},{"x":4,"y":1,"type":"water"},{"x":0,"y":2,"type":"water"},{"x":2,"y":2,"type":"tree"},{"x":4,"y":2,"type":"water"},{"x":0,"y":3,"type":"water"},{"x":2,"y":3,"type":"tree"},{"x":4,"y":3,"type":"water"},{"x":0,"y":4,"type":"water"},{"x":1,"y":4,"type":"water"},{"x":2,"y":4,"type":"water"},{"x":3,"y":4,"type":"water"},{"x":4,"y":4,"type":"water"}],
        cheeses:[{"x":2,"y":1},{"x":1,"y":2},{"x":3,"y":2}],
        mouseHoles: [],
        optimalBlocks:6,
        allowedBlocks:["turnLeft","turnRight","cheese","repeat","function"],
        functionLocked:false,
        functionContents:[{"type":"step"},{"type":"step"},{"type":"turnLeft"}]
        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 4,
        name: "Functions with Turning",
        grid: { cols: 5, rows: 5 },
        start: { x: 0, y: 0, dir: "E" },
        home:{x:4,y:4},
        obstacles:[{"x":2,"y":0,"type":"tree"},{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":4,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:8,
        allowedBlocks:["step","turnLeft","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"step"},{"type":"turnRight"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 5,
        name: "Functions with Turning",
        grid: { cols: 9, rows: 5 },
        start: { x: 8, y: 4, dir: "N" },
        home:{x:0,y:0},
        obstacles:[{"x":3,"y":0,"type":"tree"},{"x":4,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":6,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":8,"y":0,"type":"tree"},{"x":0,"y":1,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":7,"y":1,"type":"tree"},{"x":8,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":3,"y":2,"type":"tree"},{"x":7,"y":2,"type":"tree"},{"x":8,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":5,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"},{"x":7,"y":4,"type":"tree"}],
        cheeses:[{"x":1,"y":0},{"x":3,"y":1},{"x":5,"y":2},{"x":7,"y":3}],
        mouseHoles: [],
        optimalBlocks:10,
        allowedBlocks:["step","turnLeft","turnRight","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"cheese"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 6,
        name: "Functions with Loops Inside",
        grid: { cols: 6, rows: 6 },
        start: { x: 0, y: 5, dir: "N" },
        home:{x:2,y:2},
        obstacles:[{"x":1,"y":1,"type":"wall"},{"x":2,"y":1,"type":"wall"},{"x":3,"y":1,"type":"wall"},{"x":4,"y":1,"type":"wall"},{"x":1,"y":2,"type":"wall"},{"x":1,"y":3,"type":"wall"},{"x":4,"y":3,"type":"wall"},{"x":1,"y":4,"type":"wall"},{"x":2,"y":4,"type":"wall"},{"x":3,"y":4,"type":"wall"},{"x":4,"y":4,"type":"wall"},{"x":1,"y":5,"type":"wall"}],
        cheeses:[{"x":4,"y":0},{"x":0,"y":1},{"x":3,"y":2},{"x":5,"y":4}],
        mouseHoles: [{"color":2,"x1":4,"y1":2,"x2":2,"y2":5}],
        optimalBlocks:11,
        allowedBlocks:["step","turnRight","cheese","function"]
        ,
        functionLocked:false,
        functionContents:[]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 7,
        name: "Functions with Loops Inside",
        grid: { cols: 6, rows: 6 },
        start: { x: 0, y: 5, dir: "N" },
        home:{x:2,y:2},
        obstacles:[{"x":1,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":3,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":1,"y":2,"type":"tree"},{"x":1,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":1,"y":5,"type":"tree"}],
        cheeses:[{"x":4,"y":0},{"x":0,"y":1},{"x":3,"y":2},{"x":5,"y":4}],
        mouseHoles: [{"color":2,"x1":4,"y1":2,"x2":2,"y2":5}],
        optimalBlocks:7,
        allowedBlocks:["step","turnRight","cheese","repeat","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"repeat","count":4,"children":[{"type":"step"}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 8,
        name: "Functions with Loops Inside",
        grid: { cols: 9, rows: 5 },
        start: { x: 8, y: 4, dir: "N" },
        home:{x:0,y:0},
        obstacles:[{"x":4,"y":0,"type":"water"},{"x":0,"y":1,"type":"tree"},{"x":1,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":4,"y":1,"type":"water"},{"x":5,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":7,"y":1,"type":"tree"},{"x":0,"y":2,"type":"water"},{"x":1,"y":2,"type":"water"},{"x":2,"y":2,"type":"water"},{"x":3,"y":2,"type":"water"},{"x":4,"y":2,"type":"water"},{"x":5,"y":2,"type":"water"},{"x":6,"y":2,"type":"water"},{"x":7,"y":2,"type":"water"},{"x":8,"y":2,"type":"water"},{"x":4,"y":3,"type":"water"},{"x":0,"y":4,"type":"tree"},{"x":1,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":4,"y":4,"type":"water"},{"x":5,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"},{"x":7,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":5,"y1":3,"x2":3,"y2":4},{"color":2,"x1":8,"y1":1,"x2":0,"y2":3},{"color":3,"x1":5,"y1":0,"x2":3,"y2":1}],
        optimalBlocks:7,
        allowedBlocks:["step","turnLeft","turnRight","repeat","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"repeat","count":3,"children":[{"type":"step"}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

(   function(){ var L = {
        levelId: 7,
        challengeId: 9,
        name: "Functions with Loops",
        grid: { cols: 9, rows: 5 },
        start: { x: 8, y: 4, dir: "N" },
        home:{x:0,y:0},
        obstacles:[{"x":4,"y":0,"type":"water"},{"x":0,"y":1,"type":"wall"},{"x":1,"y":1,"type":"wall"},{"x":2,"y":1,"type":"wall"},{"x":4,"y":1,"type":"water"},{"x":5,"y":1,"type":"wall"},{"x":6,"y":1,"type":"wall"},{"x":7,"y":1,"type":"wall"},{"x":0,"y":2,"type":"water"},{"x":1,"y":2,"type":"water"},{"x":2,"y":2,"type":"water"},{"x":4,"y":2,"type":"water"},{"x":5,"y":2,"type":"water"},{"x":6,"y":2,"type":"water"},{"x":7,"y":2,"type":"water"},{"x":4,"y":3,"type":"water"},{"x":0,"y":4,"type":"wall"},{"x":1,"y":4,"type":"wall"},{"x":2,"y":4,"type":"wall"},{"x":4,"y":4,"type":"water"},{"x":5,"y":4,"type":"wall"},{"x":6,"y":4,"type":"wall"},{"x":7,"y":4,"type":"wall"}],
        cheeses:[],
        mouseHoles: [{"color":1,"x1":5,"y1":3,"x2":3,"y2":4},{"color":2,"x1":8,"y1":2,"x2":0,"y2":3},{"color":3,"x1":5,"y1":0,"x2":3,"y2":2}],
        optimalBlocks:10,
        allowedBlocks:["step","repeat","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"step"},{"type":"turnLeft"},{"type":"repeat","count":3,"children":[{"type":"step"}]},{"type":"turnRight"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 7,
        challengeId: 10,
        name: "Functions with Loops",
        grid: { cols: 9, rows: 5 },
        start: { x: 0, y: 0, dir: "E" },
        home:{x:8,y:0},
        obstacles:[{"x":0,"y":1,"type":"tree"},{"x":2,"y":1,"type":"tree"},{"x":4,"y":1,"type":"tree"},{"x":6,"y":1,"type":"tree"},{"x":8,"y":1,"type":"tree"},{"x":0,"y":2,"type":"tree"},{"x":2,"y":2,"type":"tree"},{"x":4,"y":2,"type":"tree"},{"x":6,"y":2,"type":"tree"},{"x":8,"y":2,"type":"tree"},{"x":0,"y":3,"type":"tree"},{"x":2,"y":3,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":6,"y":3,"type":"tree"},{"x":8,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":4,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"},{"x":8,"y":4,"type":"tree"}],
        cheeses:[{"x":1,"y":4},{"x":3,"y":4},{"x":5,"y":4},{"x":7,"y":4}],
        mouseHoles: [],
        optimalBlocks:10,
        allowedBlocks:["step","cheese","repeat","function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"turnRight"},{"type":"repeat","count":4,"children":[{"type":"step"}]},{"type":"turnRight"}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 8,
        challengeId: 1,
        name: "\"If\" block",
        grid: { cols: 10, rows: 5 },
        start: { x: 0, y: 2, dir: "E" },
        home:{x:9,y:2},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":9,"y":1,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"},{"x":9,"y":4,"type":"tree"}],
        cheeses:[{"x":2,"y":2},{"x":3,"y":2},{"x":6,"y":2},{"x":8,"y":2}],
        mouseHoles: [],
        optimalBlocks:13,
        allowedBlocks:["step","cheese"]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks
        }; })(),
    
    (function(){ var L = {
        levelId: 8,
        challengeId: 2,
        name: "\"If\" block",
        grid: { cols: 10, rows: 5 },
        start: { x: 0, y: 2, dir: "E" },
        home:{x:9,y:2},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":7,"y":0,"type":"tree"},{"x":5,"y":1,"type":"tree"},{"x":9,"y":1,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":6,"y":4,"type":"tree"},{"x":9,"y":4,"type":"tree"}],
        cheeses:[{"x":2,"y":2},{"x":3,"y":2},{"x":6,"y":2},{"x":8,"y":2}],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"repeat","count":9,"children":[{"type":"step"},{"type":"if","choice":"cheese","children":[{"type":"cheese"}]}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),
    
    (function(){ var L = {
        levelId: 8,
        challengeId: 3,
        name: "\"If\" block",
        grid: { cols: 5, rows: 5 },
        start: { x: 0, y: 1, dir: "E" },
        home:{x:2,y:4},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":4,"y":1,"type":"C1"},{"x":2,"y":2,"type":"tree"},{"x":0,"y":4,"type":"tree"},{"x":4,"y":4,"type":"C1"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["function"]
        ,
        functionLocked:true,
        functionContents:[{"type":"repeat","count":9,"children":[{"type":"step"},{"type":"if","choice":"C1","children":[{"type":"turnRight"}]}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 8,
        challengeId: 4,
        name: "\"If\" block",
        grid: { cols: 5, rows: 5 },
        start: { x: 2, y: 4, dir: "N" },
        home:{x:0,y:2},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":0,"y":1,"type":"C2"},{"x":2,"y":1,"type":"C2"},{"x":3,"y":3,"type":"tree"},{"x":0,"y":4,"type":"tree"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:5,
        allowedBlocks:["turnLeft","turnRight","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"repeat","count":7,"children":[{"type":"step"},{"type":"if","choice":"C2","children":[{"type":"turnRight"}]}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 8,
        challengeId: 5,
        name: "\"If\" block",
        grid: { cols: 5, rows: 5 },
        start: { x: 4, y: 0, dir: "W" },
        home:{x:0,y:2},
        obstacles:[{"x":0,"y":0,"type":"tree"},{"x":2,"y":0,"type":"C2"},{"x":2,"y":2,"type":"C1"},{"x":4,"y":2,"type":"tree"},{"x":3,"y":3,"type":"tree"},{"x":4,"y":3,"type":"water"},{"x":0,"y":4,"type":"tree"},{"x":2,"y":4,"type":"tree"},{"x":3,"y":4,"type":"water"},{"x":4,"y":4,"type":"water"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["turnLeft","turnRight","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"repeat","count":6,"children":[{"type":"step"},{"type":"if","choice":"C2","children":[]},{"type":"if","choice":"C1","children":[]}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 8,
        challengeId: 6,
        name: "\"If\" block",
        grid: { cols: 5, rows: 5 },
        start: { x: 1, y: 0, dir: "S" },
        home:{x:0,y:4},
        obstacles:[{"x":4,"y":0,"type":"tree"},{"x":1,"y":1,"type":"C1"},{"x":3,"y":1,"type":"C2"},{"x":0,"y":2,"type":"wall"},{"x":1,"y":2,"type":"wall"},{"x":2,"y":2,"type":"wall"},{"x":4,"y":2,"type":"wall"},{"x":0,"y":3,"type":"C1"},{"x":3,"y":3,"type":"C2"},{"x":4,"y":3,"type":"tree"},{"x":3,"y":4,"type":"tree"},{"x":4,"y":4,"type":"water"}],
        cheeses:[],
        mouseHoles: [],
        optimalBlocks:7,
        allowedBlocks:["turnLeft","turnRight","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"repeat","count":6,"children":[{"type":"step"},{"type":"if","choice":"C2","children":[]},{"type":"if","choice":"C1","children":[]}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 8,
        challengeId: 7,
        name: "\"If\" block",
        grid: { cols: 8, rows: 6 },
        start: { x: 4, y: 1, dir: "W" },
        home:{x:6,y:3},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":2,"y":1,"type":"C1"},{"x":0,"y":2,"type":"tree"},{"x":6,"y":2,"type":"wall"},{"x":5,"y":3,"type":"wall"},{"x":7,"y":3,"type":"wall"},{"x":2,"y":4,"type":"C1"},{"x":6,"y":4,"type":"C1"},{"x":0,"y":5,"type":"tree"},{"x":5,"y":5,"type":"wall"},{"x":7,"y":5,"type":"wall"}],
        cheeses:[{"x":3,"y":1},{"x":2,"y":2},{"x":2,"y":3},{"x":3,"y":4},{"x":4,"y":4},{"x":5,"y":4}],
        mouseHoles: [],
        optimalBlocks:8,
        allowedBlocks:["step","turnLeft","turnRight","cheese","function"]
        ,
        functionLocked:false,
        functionContents:[{"type":"repeat","count":6,"children":[{"type":"step"},{"type":"if","choice":"cheese","children":[]},{"type":"if","choice":"C1","children":[]}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    (function(){ var L = {
        levelId: 8,
        challengeId: 8,
        name: "\"If\" block",
        grid: { cols: 8, rows: 6 },
        start: { x: 1, y: 2, dir: "S" },
        home:{x:7,y:4},
        obstacles:[{"x":1,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":3,"y":1,"type":"C2"},{"x":5,"y":1,"type":"C2"},{"x":2,"y":2,"type":"tree"},{"x":7,"y":2,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":1,"y":4,"type":"C1"},{"x":3,"y":4,"type":"C1"},{"x":5,"y":4,"type":"C1"},{"x":0,"y":5,"type":"tree"},{"x":7,"y":5,"type":"tree"}],
        cheeses:[{"x":4,"y":1},{"x":5,"y":3},{"x":2,"y":4},{"x":6,"y":4}],
        mouseHoles: [],
        optimalBlocks:10,
        allowedBlocks:["step","turnLeft","turnRight","cheese","function","repeatUntil","if","repeat"]
        ,
        functionLocked:false,
        functionContents:[{"type":"repeat","count":6,"children":[{"type":"step"},{"type":"if","choice":"cheese","children":[]},{"type":"if","choice":"C1","children":[]},{"type":"if","choice":"C2","children":[]}]}]

        }
        return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
        }; })(),

    // (function(){ var L = {
    //     levelId: 8,
    //     challengeId: 8,
    //     name: "\"If\" block",
    //     grid: { cols: 8, rows: 6 },
    //     start: { x: 1, y: 2, dir: "S" },
    //     home:{x:7,y:4},
    //     obstacles:[{"x":1,"y":0,"type":"tree"},{"x":5,"y":0,"type":"tree"},{"x":3,"y":1,"type":"C2"},{"x":5,"y":1,"type":"C2"},{"x":2,"y":2,"type":"tree"},{"x":7,"y":2,"type":"tree"},{"x":4,"y":3,"type":"tree"},{"x":1,"y":4,"type":"C1"},{"x":3,"y":4,"type":"C1"},{"x":5,"y":4,"type":"C1"},{"x":0,"y":5,"type":"tree"},{"x":7,"y":5,"type":"tree"}],
    //     cheeses:[{"x":4,"y":1},{"x":5,"y":3},{"x":2,"y":4},{"x":6,"y":4}],
    //     mouseHoles: [],
    //     optimalBlocks:10,
    //     allowedBlocks:["turnLeft","turnRight","cheese","function"]
    //     ,
    //     functionLocked:false,
    //     functionContents:[{"type":"repeat","count":6,"children":[{"type":"step"},{"type":"if","choice":"cheese","children":[]},{"type":"if","choice":"C1","children":[]},{"type":"if","choice":"C2","children":[]}]}]

    //     }
    //     return { levelId: L.levelId, challengeId: L.challengeId, name: L.name,grid: L.grid, start: L.start, home: L.home,obstacles: L.obstacles, cheeses: L.cheeses, mouseHoles: L.mouseHoles, optimalBlocks: L.optimalBlocks, allowedBlocks: L.allowedBlocks, functionLocked: L.functionLocked, functionContents: L.functionContents
    //     }; })(),

];



  // === State ===
var state={
    teleportCooldown:null,
    teleport:null,
    level:null,
    program:[],
    ip:0,
    running:false,
    pos:{x:0,y:0},
    dir:"E",
    soundsMuted:false,
    cheeses:[], 
    plan:[], 
    errorId:null, 
    pauseIntent:false,
    functionEnabled: false,
    functionLocked: false,
    functionProgram: [],   // editable contents
    functionInit: []      // initial contents (from challenge)
};

// --- Cat capture visual state ---
state.catActive = false;           // show cat instead of mouse
state.catFx = null;                // { t0, dir, duration, progress }
state._rafCat = null;              // requestAnimationFrame handle
state.halted = false;              // to know if you've hit an obstacle
state.changed = false;

// Top-bar element refs
var muteToggle = null, btnClear = null;
var board,ctx,programBar,blockMenu,startBtn,stepBtn,resetBtn,optimalEl,yourEl,levelNameEl,winBanner,nextOrResetBtn,muteToggle,btnClear; var btnPlay;
var dropHandled=false, overDropzone=false;


// === Button Icons (SVG) ===
function svgNode(w,h){ var s=document.createElementNS("http://www.w3.org/2000/svg","svg"); s.setAttribute("viewBox","0 0 "+w+" "+h); return s; }
function playIcon(){ var s=svgNode(100,100); var tri=document.createElementNS(s.namespaceURI,"polygon"); tri.setAttribute("points","28,18 28,82 82,50"); tri.setAttribute("fill","#ffffff"); s.appendChild(tri); return s; }
function pauseIcon(){ var s=svgNode(100,100); var r1=document.createElementNS(s.namespaceURI,"rect"); r1.setAttribute("x","28"); r1.setAttribute("y","18"); r1.setAttribute("width","16"); r1.setAttribute("height","64"); r1.setAttribute("rx","4"); r1.setAttribute("fill","#ffffff"); var r2=r1.cloneNode(true); r2.setAttribute("x","56"); s.appendChild(r1); s.appendChild(r2); return s; }
function stepIcon(){ var s=svgNode(100,100); var tri=document.createElementNS(s.namespaceURI,"polygon"); tri.setAttribute("points","20,18 20,82 66,50"); tri.setAttribute("fill","#ffffff"); var bar=document.createElementNS(s.namespaceURI,"rect"); bar.setAttribute("x","70"); bar.setAttribute("y","22"); bar.setAttribute("width","10"); bar.setAttribute("height","56"); bar.setAttribute("rx","3"); bar.setAttribute("fill","#ffffff"); s.appendChild(tri); s.appendChild(bar); return s; }

function resetIcon(){ 
  var s=svgNode(100,100); 
  var p=document.createElementNS(s.namespaceURI,"path"); 
  p.setAttribute("fill","none"); 
  p.setAttribute("stroke","#ffffff"); 
  p.setAttribute("stroke-width","10"); 
  p.setAttribute("stroke-linecap","round"); 
  p.setAttribute("stroke-linejoin","round"); 
  p.setAttribute("d","M70 30h-9l7-7 M30 70h9l-7 7 M34 42a20 20 0 0 1 30-10 M66 58a20 20 0 0 1-30 10"); 
  s.appendChild(p); 
  return s; 
}

function repeatGlyphIcon(){               // tiny dark-grey, reset-style mark
  var s = svgNode(100,100);
  var p = document.createElementNS(s.namespaceURI,"path");
  p.setAttribute("fill","none");
  p.setAttribute("stroke","#444");        // dark grey
  p.setAttribute("stroke-width","10");
  p.setAttribute("stroke-linecap","round");
  p.setAttribute("stroke-linejoin","round");
  // same geometry as resetIcon (compact swirl)
  p.setAttribute("d","M70 30h-9l7-7 M30 70h9l-7 7 M34 42a20 20 0 0 1 30-10 M66 58a20 20 0 0 1-30 10");
  s.appendChild(p);
  return s;
}

function repeatUntilGlyphIcon(){
  var s = svgNode(100,100);
  var p = document.createElementNS(s.namespaceURI,"path");
  p.setAttribute("fill","none");
  p.setAttribute("stroke", getComputedStyle(document.documentElement).getPropertyValue('--cheeseInk') || '#4B2C82');
  p.setAttribute("stroke-width","10");
  p.setAttribute("stroke-linecap","round");
  p.setAttribute("stroke-linejoin","round");
  p.setAttribute("d","M70 30h-9l7-7 M30 70h9l-7 7 M34 42a20 20 0 0 1 30-10 M66 58a20 20 0 0 1-30 10");
  s.appendChild(p);
  return s;
}

function renderButtons(){ 
  btnPlay.innerHTML=""; 
  btnStep.innerHTML=""; 
  btnReset.innerHTML=""; 
  btnStep.appendChild(stepIcon()); 
  btnReset.appendChild(resetIcon()); 
  if(state.running) btnPlay.appendChild(pauseIcon()); 
  else btnPlay.appendChild(playIcon()); 
}

// === Audio ===
(function(){
  const AC = window.AudioContext || window.webkitAudioContext;
  let ctx;                 // lazy-init to satisfy autoplay policies

  function ensureCtx(){
    if (!ctx) ctx = new AC();
    if (ctx.state === 'suspended') ctx.resume();
    return ctx;
  }

  function tone(freq, dur=0.12, type='sine', gain=0.06, when){
    const c = ensureCtx(); if (window.state && state.soundsMuted) return when || c.currentTime;
    const t = when ?? c.currentTime;
    const osc = c.createOscillator(), g = c.createGain();
    osc.type = type; osc.frequency.value = freq;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(gain, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    osc.connect(g).connect(c.destination);
    osc.start(t); osc.stop(t + dur + 0.05);
    return t + dur;
  }

  function sweep(f1, f2, dur=0.25, type='sine', gain=0.06, when){
    const c = ensureCtx(); if (window.state && state.soundsMuted) return when || c.currentTime;
    const t = when ?? c.currentTime;
    const osc = c.createOscillator(), g = c.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(f1, t);
    osc.frequency.linearRampToValueAtTime(f2, t + dur);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(gain, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    osc.connect(g).connect(c.destination);
    osc.start(t); osc.stop(t + dur + 0.05);
    return t + dur;
  }

  // One public function that understands all cues used in the app.
  window.beep = function(name){
    switch(name){
      case 'move':    tone(660, 0.10, 'triangle'); break;
      case 'turn':    tone(520, 0.10, 'square');   break;
      case 'bonk':    tone(180, 0.18, 'sawtooth', 0.08); break;
      case 'pickup':  tone(760, 0.12, 'triangle'); tone(920, 0.12, 'triangle', 0.05, ensureCtx().currentTime + 0.08); break;
      case 'win':     
            sweep(420, 1300, 0.35, 'triangle', 0.07);
            //tone(900, 0.12, 'triangle'); 
            tone(1100, 0.14,'triangle', 0.06, ensureCtx().currentTime + 0.30); 
            break;
      case 'win12':
            // a pleasant downward sweep, then a tiny thud
            sweep(1300, 420, 0.35, 'triangle', 0.07);
            //tone(240, 0.10, 'square', 0.045, ensureCtx().currentTime + 0.36);
            break;
      case 'hole-in':  sweep(1000, 300, 0.28, 'sine', 0.07); tone(220, 0.09, 'square', 0.05, ensureCtx().currentTime + 0.28); break;
      case 'hole-out': tone(500, 0.08, 'triangle'); tone(750, 0.08, 'triangle', 0.06, ensureCtx().currentTime + 0.06); tone(1000, 0.10, 'triangle', 0.06, ensureCtx().currentTime + 0.12); break;
    }
  };
})();


// === Utils ===
function uid(){return Math.random().toString(36).slice(2,9)}
function dirVec(d){return d==="N"?{x:0,y:-1}: d==="S"?{x:0,y:1}: d==="W"?{x:-1,y:0}:{x:1,y:0}}
function turnLeft(d){return d==="N"?"W": d==="W"?"S": d==="S"?"E":"N"}
function turnRight(d){return d==="N"?"E": d==="E"?"S": d==="S"?"W":"N"}
function tileAt(x,y){ var L=state.level; if(x<0||y<0||x>=L.grid.cols||y>=L.grid.rows) return "off"; for(var i=0;i<L.obstacles.length;i++){ var o=L.obstacles[i]; if(o.x===x&&o.y===y) return o.type; } if(L.home.x===x&&L.home.y===y) return "home"; if(L.start.x===x&&L.start.y===y) return "start"; return "empty"; }
function getCSS(n){ var v=getComputedStyle(document.documentElement).getPropertyValue(n); return (v||'').trim(); }

function saveProgram(){ 
  try{ 
    var ch={levelId:state.current.levelId, challengeId:state.current.challengeId}; 
    saveProgFor(ch, state.program); 
    saveFnFor(ch, state.functionProgram);
  }catch(e){} }

function loadProgram(){ 
  try{ 
    var ch={levelId:state.current.levelId, challengeId:state.current.challengeId}; 
    state.program = loadProgFor(ch);
    state.functionProgram = loadFnFor(ch); 
  }catch(e){} 
}

function updateYourCount(){
  var n = countBlocks(state.program) + (state.functionEnabled ? countBlocks(state.functionProgram) : 0);
  if (yourEl) yourEl.textContent = n;
}



// === Geometry: keep grid cells square, do not exceed current height; width may expand ===
function updateBoardGeometry(){
    if(!board) return;
    var L = state.level;
    if(!L || !L.grid) return;
    var rows = L.grid.rows || L.grid.h || (L.size && L.size.rows);
    var cols = L.grid.cols || L.grid.w || (L.size && L.size.cols);
    if(!rows || !cols) return;

    // Use layout hints from resizeLayout(), then pick a square cell that fits BOTH axes
    var wrap = board.parentElement || document.body;

    // 1) Available layout space from resizeLayout()
    var hintH = Number(board.dataset.availH) || 0;
    var hintW = Number(board.dataset.availW) || 0;

    // 2) Measure container width as a fallback (board-wrap constrains width)
    var wrapW = Math.max(1, wrap.clientWidth || 1);

    // Final available width/height for the board this frame
    var availW = Math.max(1, hintW || wrapW);
    var availH = Math.max(1, hintH || (board.clientHeight || 1));

    // 3) Choose square cell that fits both axes
    var cell = Math.floor(Math.min(availW / cols, availH / rows));
    if (cell < 1) cell = 1;

    var newW = cell * cols;
    var newH = cell * rows;

    // 4) Update backing store (this resets context), then refresh ctx
    if (board.width  !== newW)  board.width  = newW;
    if (board.height !== newH)  board.height = newH;
    try{ ctx = board.getContext && board.getContext('2d'); }catch(_){}

    // 5) Mirror to CSS size (no stretch)
    board.style.width  = newW + "px";
    board.style.height = newH + "px";
setCanvasBackingScale(board);

    // 6) Keep handles for drawing
    state.cellSize = cell;
    state.boardW = newW;
    state.boardH = newH;

    if (ctx){ try{ ctx.imageSmoothingEnabled = false; }catch(_){ } }
}

  
  function countBlocks(arr){
    var n = 0;
    for (var i = 0; i < arr.length; i++){
        var b = arr[i];
        n += 1; // count this block itself
        if (b.type === "repeat" || b.type === "if" || b.type === "repeatUntil"){
            n += countBlocks(b.children || []);
        }
    }
    return n;
  }
  
  // === Icons ===
  function iconFor(t){ if(t==="step")return "üë£"; if(t==="cheese") return null; return null; }
  function arrowSVG(dir){
    var s=document.createElementNS("http://www.w3.org/2000/svg","svg"); 
    s.setAttribute("viewBox","0 0 64 64"); 
    s.classList.add("blk-arrow");
    var shaft=document.createElementNS(s.namespaceURI,"path");
    shaft.setAttribute("fill","none");
    shaft.setAttribute("stroke","currentColor");
    shaft.setAttribute("stroke-width","10");
    shaft.setAttribute("stroke-linecap","round");
    shaft.setAttribute("stroke-linejoin","round");
    var head=document.createElementNS(s.namespaceURI,"polygon");
    head.setAttribute("fill","currentColor");
    if(dir==="left"){
      shaft.setAttribute("d","M46 46 C 50 26 36 20 33 20");
      head.setAttribute("points","18,20 34,9 34,31");
    } else {
      shaft.setAttribute("d","M18 46 C 14 26 28 20 31 20");
      head.setAttribute("points","46,20 30,9 30,31");
    }
    s.appendChild(shaft); s.appendChild(head); return s;
  }
  function cheeseSVG(){ var s=document.createElementNS("http://www.w3.org/2000/svg","svg"); s.setAttribute("viewBox","0 0 64 64"); s.classList.add("blk-svg");
    var bg=document.createElementNS(s.namespaceURI,"rect"); bg.setAttribute("x","6"); bg.setAttribute("y","6"); bg.setAttribute("rx","12"); bg.setAttribute("ry","12"); bg.setAttribute("width","52"); bg.setAttribute("height","52"); bg.setAttribute("fill","var(--cheese)");
    var g=document.createElementNS(s.namespaceURI,"path"); g.setAttribute("fill","none"); g.setAttribute("stroke","var(--cheeseInk)"); g.setAttribute("stroke-width","6"); g.setAttribute("stroke-linejoin","round"); g.setAttribute("d","M19 24 L45 16 L45 48 L19 40 Z M19 24 L45 30");
    var h1=document.createElementNS(s.namespaceURI,"circle"); h1.setAttribute("cx","26"); h1.setAttribute("cy","30"); h1.setAttribute("r","3"); h1.setAttribute("fill","var(--cheeseInk)");
    var h2=document.createElementNS(s.namespaceURI,"circle"); h2.setAttribute("cx","35"); h2.setAttribute("cy","34"); h2.setAttribute("r","4"); h2.setAttribute("fill","var(--cheeseInk)");
    var h3=document.createElementNS(s.namespaceURI,"circle"); h3.setAttribute("cx","32"); h3.setAttribute("cy","42"); h3.setAttribute("r","3"); h3.setAttribute("fill","var(--cheeseInk)");
    s.appendChild(bg); s.appendChild(g); s.appendChild(h1); s.appendChild(h2); s.appendChild(h3); return s; }
  
  function repeatIconSVG(){
    var s=document.createElementNS("http://www.w3.org/2000/svg","svg"); s.setAttribute("viewBox","0 0 64 64"); s.classList.add("repeat-icon");
    var p=document.createElementNS(s.namespaceURI,"path"); p.setAttribute("fill","none"); p.setAttribute("stroke","var(--repeatInk)"); p.setAttribute("stroke-width","6"); p.setAttribute("stroke-linecap","round"); p.setAttribute("stroke-linejoin","round");
    p.setAttribute("d","M44 20h-8l6-6M20 44h8l-6 6 M22 26a12 12 0 0 1 18-6 M42 38a12 12 0 0 1-18 6");
    s.appendChild(p); return s;
  }

function homeTinySVG(){
    const ns = "http://www.w3.org/2000/svg";
    const s  = document.createElementNS(ns,"svg");
    s.setAttribute("viewBox","0 0 24 24");
    s.classList.add("icon");

    // Roof (red) ‚Äî triangle
    const roof = document.createElementNS(ns,"path");
    roof.setAttribute("d","M5 12 L12 6 L19 12 Z");
    roof.setAttribute("fill","#d64c4c");

    // Body (orange) ‚Äî rounded rect
    const body = document.createElementNS(ns,"rect");
    body.setAttribute("x","7"); body.setAttribute("y","12");
    body.setAttribute("width","10"); body.setAttribute("height","7");
    body.setAttribute("rx","1.5");
    body.setAttribute("fill","#efaa3a");

    s.appendChild(roof);
    s.appendChild(body);
    return s;
}

// === Program structure helpers ===

function clearMiuMiuLocal(){
  try{
    const PREFIXES = ["hc_v2_prog_", "hc_v2_fn_", "hc_v2_stars_", "hc_v2_last_player"];
    for (let i = localStorage.length - 1; i >= 0; i--){
      const k = localStorage.key(i);
      if (PREFIXES.some(p => k && k.startsWith(p))){
        localStorage.removeItem(k);
      }
    }
  }catch(_){}
}

function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  // replace the current getContainerByPath with this
function getContainerByPath(root, path){
    var arr = root;
    for (var i = 0; i < (path || []).length; i++){
        var seg  = path[i];
        var next = path[i+1];

        if (typeof seg === "number"){
        if (next === "children"){
            if (!arr || !arr[seg] || !Array.isArray(arr[seg].children)) return null;
            arr = arr[seg].children; i++;     // consume the "children" step
        } else {
            if (!arr || typeof arr[seg] === "undefined") return null;
            arr = arr[seg];
        }
        } else if (seg === "children"){
        if (!arr || !Array.isArray(arr.children)) return null;
        arr = arr.children;
        } else {
        return null;
        }
    }
    // We want the array that contains the target node
    return Array.isArray(arr) ? arr : null;
}


  function getBlockPathById(root, id, path){
    path = path||[];
    for(var i=0;i<root.length;i++){
        var b=root[i];
        if(b.id===id) return path.concat([i]);
        if (b.type === "repeat" || b.type === "if" || b.type === "repeatUntil"){
            var p2 = getBlockPathById(b.children||[], id, path.concat([i,"children"]));
            if(p2) return p2;
        }
    }
    return null;
  }
  
function removeAtPath(root, path){
  // path like [i] or [i,"children",j,"children",k]
  if(!Array.isArray(path) || !path.length) return null;
  var arr = root;
  for(var i=0;i<path.length-1;i++){
    var seg = path[i];
    var next = path[i+1];
    if(next === "children"){
      if(!arr[seg] || !Array.isArray(arr[seg].children)) return null;
      arr = arr[seg].children;
      i++; // skip "children"
    } else {
      // stepping through object is permitted only when followed by children; no-op here
      if(arr[seg] && typeof arr[seg] === "object") { /* noop */ }
    }
  }
  var idx = path[path.length-1];
  if(!Array.isArray(arr) || idx<0 || idx>=arr.length) return null;
  return arr.splice(idx,1)[0];
}

function wireBlockDnD(el){
    setRunning(false);
    
        // match the legacy makeBlockEl behaviour
    el.draggable = true;

    // Temporarily disable repeat wrapper dragging so inner blocks drag cleanly
    el.addEventListener("pointerdown", function(){
        try{
        var rep = el.closest(".block.repeat, .block.repeat-until");
        if (rep && rep !== el){
            rep.dataset.dragSuspend = "1";
            rep.draggable = false;
        }
        }catch(_){}
    });

    // Use the existing drag engine (placeholder + payloadBar + indices)
    el.addEventListener("dragstart", function (e) {
        if ((el.dataset.root === "fn" || el.closest("#functionBar")) && state.functionLocked) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        onBlockDragStart(e);
    });

    el.addEventListener("dragend", function(e){
        // normal cleanup
        onBlockDragEnd(e);
        // Restore repeat wrapper if we suspended it
        try{
        var rep = el.closest(".block.repeat, .block.repeat-until");
        if (rep && rep.dataset.dragSuspend === "1"){
            rep.draggable = true;
            delete rep.dataset.dragSuspend;
        }
        }catch(_){}
    });
}




function insertAtPath(root, containerPath, index, block){
  var arr = root;
  for (var i = 0; i < containerPath.length; i++){
    var seg  = containerPath[i];
    var next = containerPath[i+1];

    if (typeof seg === "number"){
      if (next === "children"){
        if (!arr || !arr[seg] || !Array.isArray(arr[seg].children)) return;
        arr = arr[seg].children; i++;
      } else {
        if (!arr || typeof arr[seg] === "undefined") return;
        arr = arr[seg];
      }
    } else if (seg === "children"){
      if (!arr || !Array.isArray(arr.children)) return;
      arr = arr.children;
    } else {
      return;
    }
  }
  if (!Array.isArray(arr)) return;
  if (index < 0) index = 0;
  if (index > arr.length) index = arr.length;
  arr.splice(index, 0, block);
}



// === Rendering ===
function blockContent(el,type,block){
    el.dataset.type = type;
    el.textContent=""; 
    var icon=iconFor(type);

    if(icon){ el.textContent=icon; }
    else if(type==="cheese"){ el.appendChild(cheeseSVG()); }
    else if(type==="turnLeft"){ el.appendChild(arrowSVG("left")); }
    else if(type==="turnRight"){ el.appendChild(arrowSVG("right")); }
    else if(type==="function"){
        el.classList.add("function");
        var s = document.createElement("span");
        s.className = "fn-label";
        s.textContent = "F";
        el.appendChild(s);
    }

    else if(type==="if"){
        el.classList.add("if");

        // --- LEFT: label + selector
        var left = document.createElement("div");
        left.className = "if-left";

        var lbl = document.createElement("div");
        lbl.className = "if-label";
        lbl.textContent = "IF";
        left.appendChild(lbl);

        // selector cycles: C1, C2, C3, cheese, home
        var choices = ["C1","C2","C3","cheese","home"];
        if (!block.choice){ block.choice = "C1"; }

        var sel = document.createElement("div");
        sel.className = "if-choice";
        sel.title = "Change IF condition";
        function paintChoice(){
            sel.innerHTML = "";          // clear
            var span = document.createElement("span");
            span.className = "icon";
            if (block.choice === "C1"){ sel.style.background = "var(--C1)"; sel.style.color="transparent"; }
            else if (block.choice === "C2"){ sel.style.background = "var(--C2)"; sel.style.color="transparent"; }
            else if (block.choice === "C3"){ sel.style.background = "var(--C3)"; sel.style.color="transparent"; }
            else if (block.choice === "cheese"){ 
                sel.style.background = "#fff";
                const svg = cheeseSVG();
                svg.classList.remove("blk-svg");   // was 42x42
                svg.classList.add("icon");         // becomes 20x20 per CSS
                sel.appendChild(svg);
            }
            else if (block.choice === "home"){
                sel.style.background = "var(--home)";   // same background as grid home tile
                sel.appendChild(homeTinySVG());         // tiny two-colour house (next step)
            }
        }
        sel.addEventListener("click", function(e){
            e.stopPropagation();
            var idx = choices.indexOf(block.choice);
            block.choice = choices[(idx+1) % choices.length];
            paintChoice();
            // re-render the correct bar immediately
            if (el.dataset && el.dataset.root === "fn") { renderFunctionBar(); }
            else { renderProgram(); }
            saveProgram();
        });
        paintChoice();
        left.appendChild(sel);
        el.appendChild(left);

        // --- RIGHT: inner dropzone (like repeat-inner)
        var inner = document.createElement("div");
        var inFnLocked = (el.dataset.root === "fn" && state.functionLocked);
        inner.className = "if-inner" + (inFnLocked ? "" : " dropzone");
        inner.dataset.containerPath = JSON.stringify((el.dataset.pathJson?JSON.parse(el.dataset.pathJson):[]).concat(["children"]));
        inner.dataset.root = el.dataset.root;
        el.appendChild(inner);
    }

    else if(type==="repeat"){
        el.classList.add("repeat");

        var ic = document.createElement("div");
        ic.className = "repeat-icon";
        ic.appendChild(repeatGlyphIcon());
        el.appendChild(ic);

        var cnt=document.createElement("div"); 
        cnt.className="repeat-count"; 
        cnt.textContent=String(block.count||2);
        cnt.title="Change repeats (2..9)";
        cnt.addEventListener("click", function(e){
        e.stopPropagation();
        block.count = (block.count||2) + 1;
        if (block.count > 9) block.count = 2;
        // Re-render the correct bar immediately
        if (el.dataset && el.dataset.root === "fn") {
            renderFunctionBar();
        } else {
            renderProgram();
        }
        saveProgram();
        setRunning(false);
        state.changed = true;
        });
        el.appendChild(cnt);

        var inner=document.createElement("div"); 
        var inFnLocked = (el.dataset.root === "fn" && state.functionLocked);
        inner.className = "repeat-inner" + (inFnLocked ? "" : " dropzone"); //  no dropzone when locked

        inner.dataset.containerPath = JSON.stringify((el.dataset.pathJson?JSON.parse(el.dataset.pathJson):[]).concat(["children"]));

        // pass the block's root down to the inner dropzone
        inner.dataset.root = el.dataset.root;

        el.appendChild(inner);
    }
    else if (type === "repeatUntil"){
        el.classList.add("repeat-until");

        // Right-top: circular arrow (purple stroke)
        var ic = document.createElement("div");
        ic.className = "repeat-icon";
        ic.appendChild(repeatUntilGlyphIcon()); // you added this helper
        el.appendChild(ic);

        // Bottom-right: selector (same widget as IF)
        var choices = ["C1","C2","C3","cheese","home"];
        if (!block.choice){ block.choice = "cheese"; }

        var sel = document.createElement("div");
        sel.className = "if-choice until-choice";
        sel.title = "Change UNTIL condition";

        function paintRU(){
            sel.innerHTML = "";
            // mirror IF visuals:
            if (block.choice === "C1"){ sel.style.background = "var(--C1)"; sel.style.color="transparent"; }
            else if (block.choice === "C2"){ sel.style.background = "var(--C2)"; sel.style.color="transparent"; }
            else if (block.choice === "C3"){ sel.style.background = "var(--C3)"; sel.style.color="transparent"; }
            else if (block.choice === "cheese"){ 
            sel.style.background = "#fff";
            const svg = cheeseSVG(); svg.classList.remove("blk-svg"); svg.classList.add("icon");
            sel.appendChild(svg);
            }
            else if (block.choice === "home"){
            sel.style.background = "var(--home)";
            sel.appendChild(homeTinySVG ? homeTinySVG() : (function(){ const s=document.createElement('span'); s.textContent="üè†"; return s; })());
            }
        }

        sel.addEventListener("click", function(e){
            e.stopPropagation();
            var idx = choices.indexOf(block.choice);
            block.choice = choices[(idx+1) % choices.length];
            paintRU();
            // re-render the correct bar immediately
            if (el.dataset && el.dataset.root === "fn") { renderFunctionBar(); }
            else { renderProgram(); }
            saveProgram();
        });
        paintRU();
        el.appendChild(sel);

        // Body container (identical to repeat)
        var inner = document.createElement("div");
        var inFnLocked = (el.dataset.root === "fn" && state.functionLocked);
        inner.className = "repeat-inner" + (inFnLocked ? "" : " dropzone");
        inner.dataset.containerPath = JSON.stringify((el.dataset.pathJson?JSON.parse(el.dataset.pathJson):[]).concat(["children"]));
        inner.dataset.root = el.dataset.root;
        el.appendChild(inner);
        }

}

function makeBlockEl(block, path){
    var el=document.createElement("div"); el.className="block"; el.dataset.type=block.type; el.dataset.id=block.id; el.dataset.pathJson=JSON.stringify(path); el.draggable=true;
    blockContent(el,block.type,block);
    setRunning(false);
    
    el.addEventListener("click", function(ev){ 
        
        // alt+click needed to delete the block (added to prevent accidental deletion of blocks - especially repeat blocks)
        state.changed = true;
        if (!ev.altKey) return;

        ev.stopPropagation();
        
        // remove the clicked block (and its contents)
        var p = JSON.parse(el.dataset.pathJson||"[]");
        removeAtPath(state.program, p);
        renderProgram(); 
        saveProgram();
    });
    
    // If dragging a child inside a repeat, temporarily disable dragging on the repeat wrapper
    el.addEventListener("pointerdown", function(ev){
        try{
        var rep = el.closest(".block.repeat, .block.repeat-until");
        if(rep && rep !== el){
            rep.dataset.dragSuspend = "1";
            rep.draggable = false;
        }
        }catch(_){}
    });

    el.addEventListener("dragstart", onBlockDragStart);
    el.addEventListener("dragend", onBlockDragEnd);

    // Restore repeat wrapper draggable if we suspended it
    try{
        var rep = el.closest(".block.repeat");
        if(rep && rep.dataset.dragSuspend==="1"){
        rep.draggable = true;
        delete rep.dataset.dragSuspend;
        }
    }catch(_){}

    return el;
}

function resizeLayout(){
  try{
    const vp   = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
    const vh   = vp.height || window.innerHeight;
    const vw   = (vp.width  || window.innerWidth) - 24;

    const topbar = document.querySelector('.topbar')?.offsetHeight || 0;
    const codeUI = document.querySelector('.code-ui')?.offsetHeight || 0;
    const menu   = document.getElementById('blockMenu')?.offsetHeight || 0;

    const MIN_BOARD_H = 200;        // your minimum
    const safetyPx    = 20;         // you already have something like this
    const FUDGE       = 0.95;       // <<‚Äî about 5% smaller
    const EXTRA       = 8;          // <<‚Äî tiny buffer to kill the scroll bar

    // Raw available height for the board area
    const rawAvailH = vh - topbar - codeUI - menu - safetyPx;

    // Apply ~5% reduction and a tiny extra buffer
    const availH = Math.max(MIN_BOARD_H, Math.floor(rawAvailH * FUDGE) - EXTRA);
    const availW = Math.max(200, vw);

    const canvas = document.getElementById('board');
    if (canvas){
      // Pass hints to geometry; don‚Äôt touch backing store here
      canvas.dataset.availH = String(availH);
      canvas.dataset.availW = String(availW);

      // Optional: keep these for dev tools/visual inspection
      canvas.style.maxHeight = availH + 'px';
      canvas.style.maxWidth  = availW + 'px';

      if (typeof updateBoardGeometry === 'function'){ try{ updateBoardGeometry(); }catch(_){} }
      if (typeof draw === 'function'){ try{ draw(); }catch(_){} }
    }
  }catch(e){
    try{ showError && showError("resizeLayout()", e); }catch(_){}
  }
}




function renderContainer(arr, containerEl, pathPrefix){
    containerEl.innerHTML="";
    for(var i=0;i<arr.length;i++){
        var b=arr[i];
        var p = pathPrefix.concat([i]);
        var node = makeBlockEl(b, p);

        // tag the block with which bar it belongs to
        node.dataset.root = (containerEl.closest('#functionBar') ? 'fn' : 'program');

        containerEl.appendChild(node);
        if(!state.blockEls) state.blockEls = {};
        if(b && b.id) state.blockEls[b.id] = node;

        if (b.type === "repeat" || b.type === "if" || b.type === "repeatUntil"){
            var inner = node.querySelector(b.type === "if" ? ".if-inner" : ".repeat-inner");
            if (inner){
                renderContainer(b.children || [], inner, p.concat(["children"]));
            }
        }
    }
}

function renderProgram(){
    if(!programBar) return;
    state.blockEls = {};
    programBar.innerHTML = "";
    programBar.classList.add("dropzone");
    programBar.dataset.containerPath = JSON.stringify([]);
    programBar.dataset.root = "program";  
    renderContainerWithRoot(state.program, programBar, [], "program");
    updateYourCount();
    attachDnD();

    // ‚úÖ If we‚Äôre mid-function, keep the program call-site highlighted
    try{
        if (state.fnPlan && typeof state.fnIp === "number" && state.callId){
        highlightById(state.callId);
        }
    }catch(_){}

    try{ resizeLayout(); }catch(_){}

}

function renderFunctionBar(){
    var fnBar = document.getElementById("functionBar");
    if (!fnBar) return;

    // reset visual lock state from the previous challenge
    fnBar.classList.remove("locked");

    fnBar.classList.add("dropzone");
    fnBar.dataset.containerPath = JSON.stringify([]);   // local root path
    // IMPORTANT: root flag so DnD knows where we are
    fnBar.dataset.root = "fn";

    // extend the global map so highlight/error can find function blocks too
    if (!state.blockEls) state.blockEls = {};
    renderContainerWithRoot(state.functionProgram, fnBar, [], "fn");

    // function may be locked
    if (state.functionLocked) fnBar.classList.add("locked");
    attachDnD(); // re-wire dropzones after render

    try{ updateYourCount(); }catch(_){}
    
    fnBar.addEventListener("dragstart", function (e) {
      if (!state.functionLocked) return;
      // If a block (or inside a block) is the drag source, cancel it
      if (e.target && e.target.closest && e.target.closest(".block")) {
          e.preventDefault();
          e.stopPropagation();
      }
      }, true);

    // If we‚Äôre mid-call when a re-render happens, restore the visual cursor immediately
    try{
      if (state.fnPlan && typeof state.fnIp === "number" && state.fnIp < state.fnPlan.length){
        var cur = state.fnPlan[state.fnIp];
        if (cur && cur.id) highlightFunctionById(cur.id);
      }
    }catch(_){}

    try{ resizeLayout(); }catch(_){}


}

function renderContainerWithRoot(arr, containerEl, pathPrefix, rootTag){
    containerEl.innerHTML = "";
    for (var i=0;i<arr.length;i++){
        var b = arr[i];
        var p = pathPrefix.concat([i]);
        var node = makeBlockElWithRoot(b, p, rootTag);
        containerEl.appendChild(node);
        if(!state.blockEls) state.blockEls = {};
        if(b && b.id) state.blockEls[b.id] = node;
        if (b.type === "repeat" || b.type === "if" || b.type === "repeatUntil"){
            var inner = node.querySelector(b.type === "if" ? ".if-inner" : ".repeat-inner");
            if (inner){
                inner.dataset.root = rootTag;
                inner.dataset.containerPath = JSON.stringify(p.concat(['children']));
            }
            renderContainerWithRoot(b.children || [], inner, p.concat(['children']), rootTag);
        }
    }
}

function makeBlockElWithRoot(block, path, rootTag){
  var el = document.createElement("div"); el.className="block";
  el.dataset.id = block.id || (block.id = uid());
  el.dataset.pathJson = JSON.stringify(path);
  el.dataset.root = rootTag || "program";
  el.draggable = true;

  if ((rootTag || el.dataset.root) === "fn" && state.functionLocked){
    el.draggable = false; // no drag from function bar when locked
    el.removeAttribute("draggable");  // ensure attribute is gone (cross-browser)
  }

  blockContent(el, block.type, block, rootTag);
  el.addEventListener("click", function(ev){
    // Alt+click delete (keep behaviour)
    state.changed = true;
    if (!ev.altKey) return;
    // Do not allow deleting from locked function bar
    if (el.dataset.root === "fn" && state.functionLocked) return;
    ev.stopPropagation();
    var p = JSON.parse(el.dataset.pathJson||"[]");
    var root = el.dataset.root==="fn" ? state.functionProgram : state.program;
    removeAtPath(root, p);
    if (el.dataset.root === "fn") {
      renderFunctionBar();
      // keep functionInit in sync after delete in function bar
      state.functionInit = (state.functionProgram || []).slice();
    } else {
      renderProgram();
    }
    saveProgram();
  });
  
  if (!((rootTag || el.dataset.root) === "fn" && state.functionLocked)){
    wireBlockDnD(el);
  }

  return el;
}


function renderMenu(){
    if(!blockMenu) return;
    blockMenu.innerHTML="";
    var order=["step","turnLeft","turnRight","cheese","repeat","repeatUntil","function","if"];
    var allowed = (state.level && state.level.allowedBlocks) ? state.level.allowedBlocks.slice() : order;
    
    for(var j=0;j<order.length;j++){
        var type=order[j]; if(allowed.indexOf(type)===-1) continue;
        var btn=document.createElement("div"); btn.className="menu-block block"; btn.draggable=true; btn.dataset.type=type; btn.dataset.id="menu-"+type;
        
        if(type==="repeat"){
            btn.classList.add("repeat", "is-menu");

            // icon first (top-right)
            var ic=document.createElement("div");
            ic.className="repeat-icon";
            ic.appendChild(repeatGlyphIcon());
            btn.appendChild(ic);

            // non-interactive preview count
            var cnt=document.createElement("div");
            cnt.className="repeat-count";
            cnt.textContent="2";
            btn.appendChild(cnt);
        }
        else if (type==="if"){
            btn.classList.add("is-menu");
            // render IF but without children
            blockContent(btn, "if", { choice:"cheese", children:[] });
        }
        else if (type==="repeatUntil"){
            btn.classList.add("repeat-until", "is-menu");
            var ic=document.createElement("div");
            ic.className="repeat-icon";
            ic.appendChild(repeatUntilGlyphIcon());
            btn.appendChild(ic);

            // selector shown but inactive in the menu (disabled by CSS)
            blockContent(btn, "repeatUntil", { choice:"cheese", children:[] });
        }

        else{
            blockContent(btn,type,{});
        }

        btn.addEventListener("click", function(ev){
            var t = ev.currentTarget.dataset.type;
            // Respect function enable
            if (t==="function" && !state.functionEnabled) return;

            var max = Number(programBar.dataset.max || 20);
            if (countBlocks(state.program) >= max && t!=="repeat") return;

            if (t==="repeat"){ 
                state.program.push({id:uid(), type:"repeat", count:2, children:[]}); 
            }
            else if (t==="if"){ 
                state.program.push({id:uid(), type:"if", choice:"cheese", children:[]}); 
            }
            else if (t==="repeatUntil"){
            state.program.push({ id: uid(), type: "repeatUntil", choice: "cheese", children: [] });
            }
            else { 
                state.program.push({id:uid(), type:t}); 
            }
            renderProgram(); 
            saveProgram();
        });


        btn.addEventListener("dragstart", function(e){
        state.changed = true;
        if(!e.dataTransfer) return;
        try{
            var t = e.currentTarget && e.currentTarget.dataset ? e.currentTarget.dataset.type : null;
            e.dataTransfer.setData("text/plain", JSON.stringify({from:"menu", type: t}));
            e.dataTransfer.effectAllowed="copy";
            // Use a tight drag image so we don't drag the whole menu
            var ghost = (e.currentTarget||this).cloneNode(true);
            ghost.style.position="absolute"; ghost.style.top="-1000px"; ghost.style.left="-1000px"; ghost.style.opacity="1";
            document.body.appendChild(ghost);
            if(e.dataTransfer.setDragImage){ e.dataTransfer.setDragImage(ghost, ghost.offsetWidth/2, ghost.offsetHeight/2); }
            // Clean up ghost on dragend
            (e.currentTarget||this).addEventListener("dragend", function(){
            try{ if(ghost && ghost.parentNode){ ghost.parentNode.removeChild(ghost); } }catch(_){ }
            }, { once: true });
        }catch(_){}
        });
        blockMenu.appendChild(btn);
    }
}

// === DnD with placeholder across containers ===
var placeholder = document.createElement("div"); placeholder.className="block placeholder";
var dropHandled=false; var overDropzone=false;
var dragGhost = null;
var payloadBar = null; // info about dragging block from bar

function onBlockDragStart(e){ dropHandled=false; overDropzone=false; // Prevent bubbling to parent repeat wrappers so only the intended block is dragged
  state.changed = true;
  setRunning(false);

  if (e && e.stopPropagation) e.stopPropagation();
  var target = e.currentTarget;
  try{
    dragGhost = target.cloneNode(true);
    dragGhost.style.position="absolute"; dragGhost.style.top="-1000px"; dragGhost.style.left="-1000px"; dragGhost.style.opacity="1";
    document.body.appendChild(dragGhost);
    if (e.dataTransfer && e.dataTransfer.setDragImage){
      e.dataTransfer.setDragImage(dragGhost, dragGhost.offsetWidth/2, dragGhost.offsetHeight/2);
    }
  }catch(_){}
  var p = JSON.parse(target.dataset.pathJson||"[]");
  var rootTag = (target.closest("#functionBar") ? "fn" : "program");
  payloadBar = { from:"bar", id: target.dataset.id, path: p, root: rootTag };

  if (e.dataTransfer){
    try{ e.dataTransfer.setData("text/plain", JSON.stringify(payloadBar)); e.dataTransfer.effectAllowed="move"; }catch(_){}
  }
  target.classList.add("dragging");
  // replace with placeholder in its container
  requestAnimationFrame(function(){
    try{
      var parent = target.parentNode;
      if(parent) parent.insertBefore(placeholder, target);
      target.remove();
    }catch(_){}
  });
}

function onBlockDragEnd(e){
  // Always remove placeholder, wherever it is
  try{ if(placeholder && placeholder.parentElement){ placeholder.parentElement.removeChild(placeholder); } }catch(_){}
  
  // If this drag started from a bar and no valid drop was handled, delete the item
  try{
    if (payloadBar && payloadBar.from === 'bar' && (!dropHandled)) {
      if (Array.isArray(payloadBar.path)) {
        var sourceRoot = (payloadBar.root === 'fn') ? state.functionProgram : state.program;
        removeAtPath(sourceRoot, payloadBar.path);
        if (payloadBar.root === 'fn') {
          renderFunctionBar();
          // keep functionInit in sync after deletes in function bar
          state.functionInit = (state.functionProgram || []).slice();
        } else {
          renderProgram();
        }
        saveProgram();
        try{ updateYourCount(); }catch(_){}
      }
    }
  }catch(_){/* non-fatal */}


  // Clean up drag visuals
  try{ var t = e && e.currentTarget ? e.currentTarget : null; if(t) t.classList.remove('dragging'); }catch(_){}
  try{ if(dragGhost && dragGhost.parentNode){ dragGhost.parentNode.removeChild(dragGhost); } }catch(_){}
  dragGhost=null; payloadBar=null; dropHandled=false; overDropzone=false;
}

function getInsertIndex(containerEl, clientX){
  var kids = [].slice.call(containerEl.children);
  var idx = kids.length;
  for (var i=0;i<kids.length;i++){
    var el = kids[i];
    if(el===placeholder) continue;
    var box = el.getBoundingClientRect();
    var mid = box.left + box.width/2;
    if (clientX < mid){ idx = i; break; }
  }
  // adjust for placeholder position
  var before = [].slice.call(containerEl.children).indexOf(placeholder);
  if(before>-1 && before<idx) idx--;
  return idx;
}

function attachDropzone(el, containerPath){
    if (el.__wiredDnD) return; el.__wiredDnD = true;
    el.addEventListener("dragover", function(e){
        if (el.dataset.root === "fn" && state.functionLocked) return;  // locked

        e.preventDefault(); e.stopPropagation(); overDropzone=true;
        el.classList.add("repeat-outline");
        var idx = getInsertIndex(el, e.clientX);
        var real = [].slice.call(el.children).filter(function(n){return n!==placeholder});
        var ref = (idx >= real.length) ? null : real[idx];
        if (!placeholder.parentElement || placeholder.parentElement!==el) el.insertBefore(placeholder, ref);
        else if (placeholder.nextSibling !== ref) el.insertBefore(placeholder, ref);
        // auto-scroll when near edges
        var r = el.getBoundingClientRect();
        if (el.scrollWidth > el.clientWidth){ if (e.clientX > r.right - 40) el.scrollLeft += 20; else if (e.clientX < r.left + 40) el.scrollLeft -= 20; }
    });

    el.addEventListener("dragleave", function(e){
        if (el.dataset.root === "fn" && state.functionLocked) return;  // locked

        e.stopPropagation();
        var r = el.getBoundingClientRect();
        if (e.clientX<r.left || e.clientX>r.right || e.clientY<r.top || e.clientY>r.bottom){ overDropzone=false;
        el.classList.remove("repeat-outline");
        if (placeholder.parentElement===el) el.removeChild(placeholder);
        }
    });

    el.addEventListener("drop", function(e){
        if (el.dataset.root === "fn" && state.functionLocked) return;  // locked

        e.preventDefault(); e.stopPropagation(); dropHandled=true;
        el.classList.remove("repeat-outline");
        var idx = 0;
        for (var n=0;n<el.children.length;n++){
        var node = el.children[n];
        if (node===placeholder) break;
        if (!node.classList.contains("placeholder")) idx++;
        }
        var raw = "{}"; try{ raw=e.dataTransfer.getData("text/plain")||"{}"; }catch(_){}
        var data=null; try{ data=JSON.parse(raw); }catch(_){}
        var contPath = JSON.parse(containerPath);
    
        // Adjust container path if removal shifts indices in the same parent array
        if (payloadBar && payloadBar.from==="bar" && Array.isArray(payloadBar.path) && payloadBar.root === el.dataset.root){
        try{
            var sp = payloadBar.path.slice();
            var spParent = sp.slice(0, sp.length-1);
            var srcIdx = sp[sp.length-1];
            var dp = contPath.slice();
            for (var k=0;k<dp.length;k++){
            if (typeof dp[k] === "number"){
                var parentPath = dp.slice(0,k);
                if (JSON.stringify(parentPath) === JSON.stringify(spParent) && typeof srcIdx==="number" && srcIdx < dp[k]){
                dp[k] = dp[k]-1;
                contPath = dp;
                break;
                }
            }
            }
        }catch(_){}
        }
    
        var targetRoot = (el.dataset.root === "fn") ? state.functionProgram : state.program;
        var targetMax  = Number(el.dataset.max || (el.dataset.root === "fn" ? 10 : 20));
        var currCount  = countBlocks(targetRoot);

        // --- Insert from palette/menu
        if (data && data.from === 'menu') {
        var t = data.type;

        // Block function blocks inside the function bar
        if (el.dataset.root === "fn" && t === "function") { /* ignore */ }
        else {
            // Enforce max (repeat counts as 1 as before)
            if (currCount >= targetMax && t !== "repeat" && t !== "repeatUntil") { /* ignore */ }
            var block = (t==='repeat') 
                ? {id:uid(), type:'repeat', count:2, children:[]}
                : (t==='if')
                    ? {id:uid(), type:'if', choice:'cheese', children:[]}
                    : (t==='repeatUntil')
                    ? {id:uid(), type:'repeatUntil', choice:'cheese', children:[]}
                    : {id:uid(), type:t};

            insertAtPath(targetRoot, contPath, idx, block);
        }
        }
        // --- Move within/between bars
        else if (payloadBar && payloadBar.from === 'bar') {
        var sourceRoot = (payloadBar.root === "fn") ? state.functionProgram : state.program;
        var item = removeAtPath(sourceRoot, payloadBar.path);
        if (item){
            // Prevent dropping a function block into function bar
            if (el.dataset.root === "fn" && item.type === "function") {
            // put it back where it came from
            insertAtPath(sourceRoot, payloadBar.path.slice(0, -1), payloadBar.path[payloadBar.path.length-1], item);
            } else {
            // Enforce target max
            if (currCount >= targetMax) {
                // return to source if full
                insertAtPath(sourceRoot, payloadBar.path.slice(0, -1), payloadBar.path[payloadBar.path.length-1], item);
            } else {
                insertAtPath(targetRoot, contPath, idx, item);
            }
            }
        }
        }

        if (placeholder.parentElement===el) el.removeChild(placeholder);
        if (state.functionEnabled) renderFunctionBar();

        if (el.dataset.root === "fn") {
        state.functionInit = (state.functionProgram || []).slice();
        }

        renderProgram(); 
        saveProgram();
        
    });
}

  
function attachRepeatWrapper(el){
    if (el.__wiredRepeatDz) return; el.__wiredRepeatDz = true;
    var inner = el.querySelector('.repeat-inner.dropzone');
    if (!inner) return;
    el.addEventListener('dragover', function(e){
        e.preventDefault(); e.stopPropagation(); overDropzone=true;
        el.classList.add('repeat-outline');
        // compute index inside inner
        var idx = getInsertIndex(inner, e.clientX);
        var real = [].slice.call(inner.children).filter(function(n){return n!==placeholder});
        var ref = (idx >= real.length) ? null : real[idx];
        if (!placeholder.parentElement || placeholder.parentElement!==inner) inner.insertBefore(placeholder, ref);
        else if (placeholder.nextSibling !== ref) inner.insertBefore(placeholder, ref);
    });
    el.addEventListener('dragleave', function(e){
        e.stopPropagation(); overDropzone=false;
        var r = el.getBoundingClientRect();
        if (e.clientX<r.left || e.clientX>r.right || e.clientY<r.top || e.clientY>r.bottom){ overDropzone=false;
        el.classList.remove('repeat-outline');
        if (placeholder.parentElement===inner) inner.removeChild(placeholder);
        }
    });
    el.addEventListener('drop', function(e){
        e.preventDefault(); e.stopPropagation(); dropHandled=true;
        el.classList.remove('repeat-outline');
        var idx = 0;
        for (var n=0;n<inner.children.length;n++){
        var node = inner.children[n];
        if (node===placeholder) break;
        if (!node.classList.contains('placeholder')) idx++;
        }
        var raw="{}"; try{ raw=e.dataTransfer.getData("text/plain")||"{}"; }catch(_){}
        var data=null; try{ data=JSON.parse(raw); }catch(_){}
        
        var contPath = inner.dataset.containerPath ? JSON.parse(inner.dataset.containerPath) : [];
        // prefer the inner's root; fall back to the wrapper's; finally default to program
        var rootTag = inner.dataset.root || el.dataset.root || 'program';
        var targetRoot = (rootTag === 'fn') ? state.functionProgram : state.program;
        

        // Adjust container path if removal shifts indices in the same parent array
        if (payloadBar && payloadBar.from==="bar" && Array.isArray(payloadBar.path) && payloadBar.root === rootTag){
            try{
                var sp = payloadBar.path.slice();
                var spParent = sp.slice(0, sp.length-1);
                var srcIdx = sp[sp.length-1];
                var dp = contPath.slice();
                for (var k=0;k<dp.length;k++){
                if (typeof dp[k] === "number"){
                    var parentPath = dp.slice(0,k);
                    if (JSON.stringify(parentPath) === JSON.stringify(spParent) && typeof srcIdx==="number" && srcIdx < dp[k]){
                    dp[k] = dp[k]-1;
                    contPath = dp;
                    break;
                    }
                }
                }
            }catch(_){}
        }

        // --- SAME-PARENT SHIFT FIX (Program‚ÜíProgram) ---
        if (payloadBar && payloadBar.from === 'bar' && payloadBar.root === el.dataset.root && Array.isArray(payloadBar.path)) {
        // We‚Äôre moving a block that was in the same bar (program), so if its removal
        // was left of the repeat we‚Äôre inserting into, the repeat‚Äôs index shifts -1.
        // Adjust the numeric segment in contPath at the level right before "children".
        (function adjustForSameParent(){
            var dst = contPath.slice();
            var src = payloadBar.path.slice();
            // Walk both paths together; every time we see <number,"children"> on dst,
            // check if src removed a lower index at that same level.
            for (var i = 0, j = 0; i < dst.length && j < src.length; ){
            var d = dst[i], dNext = dst[i+1];
            var s = src[j], sNext = src[j+1];

            // Keep descending while both paths align through "children"
            if (d === s && dNext === 'children' && sNext === 'children') {
                i += 2; j += 2; continue;
            }

            // We‚Äôre at the parent array level of the repeat we‚Äôre dropping *into*.
            // dst has form [..., <idxOfRepeat>, "children", ...]
            if (typeof d === 'number' && dNext === 'children' && typeof s === 'number') {
                // If the removed source index was to the LEFT of the repeat, shift repeat index left
                if (s < d) dst[i] = d - 1;
                break;
            }

            // Different structure: nothing to adjust
            break;
            }
            contPath = dst;
        })();
        }
        // --- END SAME-PARENT SHIFT FIX ---


        if (data && data.from==='menu'){
            var t=data.type;
            var block =
                (t==='repeat')       ? { id: uid(), type: 'repeat',       count: 2,     children: [] } :
                (t==='if')           ? { id: uid(), type: 'if',           choice:'cheese', children: [] } :
                (t==='repeatUntil')  ? { id: uid(), type: 'repeatUntil',  choice:'cheese', children: [] } :
                                        { id: uid(), type: t };

            insertAtPath(targetRoot, contPath, idx, block);
        } else if (payloadBar && payloadBar.from==='bar'){
            // remove from the correct source root
            var sourceRoot = (payloadBar.root === 'fn') ? state.functionProgram : state.program;
            var item = removeAtPath(sourceRoot, payloadBar.path);
            if (item) {
                insertAtPath(targetRoot, contPath, idx, item);
            }
            // if we pulled the item out of the Function bar, keep UI + template in sync
            if (payloadBar.root === 'fn') {
                if (state.functionEnabled) renderFunctionBar();
                state.functionInit = (state.functionProgram || []).slice();
            }
        }

        if (placeholder.parentElement===inner) inner.removeChild(placeholder);
        renderProgram(); saveProgram();

        try{}finally{ try{ if(placeholder && placeholder.parentElement===inner) inner.removeChild(placeholder);}catch(_){} }

        try{}finally{ try{ if(placeholder && placeholder.parentElement===el) el.removeChild(placeholder);}catch(_){} }

        try{}finally{ try{ if(placeholder && placeholder.parentElement===inner) inner.removeChild(placeholder);}catch(_){} }
    });
}

function attachIfWrapper(el){
    if (el.__wiredIfDz) return; el.__wiredIfDz = true;
    var inner = el.querySelector('.if-inner.dropzone');
    if (!inner) return;

    el.addEventListener('dragover', function(e){
        e.preventDefault(); e.stopPropagation(); overDropzone = true;
        el.classList.add('repeat-outline'); // reuse outline style
        var idx  = getInsertIndex(inner, e.clientX);
        var real = [].slice.call(inner.children).filter(n => n !== placeholder);
        var ref  = (idx >= real.length) ? null : real[idx];
        if (!placeholder.parentElement || placeholder.parentElement !== inner) inner.insertBefore(placeholder, ref);
        else if (placeholder.nextSibling !== ref) inner.insertBefore(placeholder, ref);
    });

    el.addEventListener('dragleave', function(e){
        e.stopPropagation(); 
        var r = el.getBoundingClientRect();
        if (e.clientX<r.left || e.clientX>r.right || e.clientY<r.top || e.clientY>r.bottom){
        overDropzone=false;
        el.classList.remove('repeat-outline');
        if (placeholder.parentElement === inner) inner.removeChild(placeholder);
        }
    });

    el.addEventListener('drop', function(e){
        e.preventDefault(); e.stopPropagation(); dropHandled = true;
        el.classList.remove('repeat-outline');

        // compute insertion index inside inner
        var idx = 0;
        for (var n=0; n<inner.children.length; n++){
        var node = inner.children[n];
        if (node === placeholder) break;
        if (!node.classList.contains('placeholder')) idx++;
        }

        var raw="{}"; try{ raw = e.dataTransfer.getData("text/plain") || "{}"; }catch(_){}
        var data=null; try{ data = JSON.parse(raw); }catch(_){}

        var contPath = inner.dataset.containerPath ? JSON.parse(inner.dataset.containerPath) : [];
        var rootTag  = inner.dataset.root || el.dataset.root || 'program';
        var targetRoot = (rootTag === 'fn') ? state.functionProgram : state.program;

        // same-parent left-shift protection (keep your existing helper block if present)
        if (payloadBar && payloadBar.from==="bar" && Array.isArray(payloadBar.path) && payloadBar.root === rootTag){
        try{
            var sp = payloadBar.path.slice();
            var spParent = sp.slice(0, sp.length-1);
            var srcIdx = sp[sp.length-1];
            var dp = contPath.slice();
            for (var k=0;k<dp.length;k++){
            if (typeof dp[k] === "number"){
                var parentPath = dp.slice(0,k);
                if (JSON.stringify(parentPath) === JSON.stringify(spParent) && typeof srcIdx==="number" && srcIdx < dp[k]){
                dp[k] = dp[k]-1;
                contPath = dp;
                break;
                }
            }
            }
        }catch(_){}
        }

        var targetMax = Number(inner.dataset.max || (rootTag === "fn" ? 10 : 20));
        var currCount = countBlocks(targetRoot);

        if (data && data.from === 'menu'){
        var t = data.type;
        if (!(rootTag === "fn" && t === "function")){
            if (currCount >= targetMax && t !== "repeat" && t !== "repeatUntil"){ /* ignore */ }
            else {
            var block = (t==='repeat')
                ? { id: uid(), type:'repeat', count:2, children:[] }
                : (t==='if')
                    ? { id: uid(), type:'if', choice:'cheese', children:[] }
                    : (t==='repeatUntil')
                    ? { id: uid(), type:'repeatUntil', choice:'cheese', children:[] }
                    : { id: uid(), type:t };

            insertAtPath(targetRoot, contPath, idx, block);
            }
        }
        } else if (payloadBar && payloadBar.from === 'bar'){
        var sourceRoot = (payloadBar.root === 'fn') ? state.functionProgram : state.program;
        var item = removeAtPath(sourceRoot, payloadBar.path);
        if (item){
            if (rootTag === 'fn' && item.type === 'function'){
            insertAtPath(sourceRoot, payloadBar.path.slice(0,-1), payloadBar.path[payloadBar.path.length-1], item);
            } else if (currCount >= targetMax){
            insertAtPath(sourceRoot, payloadBar.path.slice(0,-1), payloadBar.path[payloadBar.path.length-1], item);
            } else {
            insertAtPath(targetRoot, contPath, idx, item);
            }
        }
        }

        if (placeholder.parentElement === el) el.removeChild(placeholder);
        if (state.functionEnabled) renderFunctionBar();
        if (rootTag === "fn") { state.functionInit = (state.functionProgram || []).slice(); }
        renderProgram(); 
        saveProgram();
    });
}

function attachDnD(){
    // wire all dropzones (program bar + repeat inners)
    var zones = document.querySelectorAll(".dropzone");
    zones.forEach(function(z){
        // Skip any zone under a locked function bar
        if (z.closest('#functionBar.locked')) return;
        
        var path = z.dataset.containerPath || "[]";
        attachDropzone(z, path);
    });
    // make entire repeat blocks accept drops (proxy to inner)
    document.querySelectorAll('.block.repeat').forEach(function(rep){ attachRepeatWrapper(rep); });
    // repeatUntil block accepts drops
    document.querySelectorAll('.block.repeat-until').forEach(rep => attachRepeatWrapper(rep)); 
    // if blocks accepts drops
    document.querySelectorAll('.block.if').forEach(function(node){ attachIfWrapper(node); });
    
}

// === Runner ===
var TICK_MS = 600;  
var timer=null;
state.fnPlan = null;    // current function flattened plan
state.fnIp   = 0;       // instruction pointer within function
state.callId = null;    // the program call-site block id (to keep highlighted)


  
function setRunning(on){
    state.running = on;
    if(on){
        if(timer){ clearInterval(timer); timer=null; }
        if(typeof clearErrorHighlight==='function'){ clearErrorHighlight(); }
        state.plan = flatten(state.program);
        state.ip = 0;
        state.fnPlan = null; state.fnIp = 0; state.callId = null;
        if(!state || !state.errorId){ highlightById(null); }

        // Game timer
        timer = setInterval(function(){
        stepOnce(true);
        }, TICK_MS);

    } else {
        clearInterval(timer); 
        timer=null;
        cancelStepPause();
        // Only clear program highlight when we are *not* pausing (e.g., stop/reset/end)
        if (!state.pauseIntent && (!state || !state.errorId)) {
        highlightById(null);
        }
    }

    state.pauseIntent=false;
    renderButtons();
}

let stepPauseTimer = null;
let stepPauseToken = 0;

function scheduleStepPause(ms, fn){
  clearTimeout(stepPauseTimer);
  const tok = ++stepPauseToken;
  stepPauseTimer = setTimeout(() => {
    if (tok !== stepPauseToken) return;   // cancelled by pause/reset/start
    fn();
  }, ms);
}

// Call this in your reset/stop/pause paths:
function cancelStepPause(){
  clearTimeout(stepPauseTimer);
  stepPauseToken++;
}

function flatten(arr){
  var out=[];
  for(var i=0;i<arr.length;i++){
    var b=arr[i];
    if(b.type==="repeat"){
      var times = Math.max(2, Math.min(9, b.count||2));
      for(var t=0;t<times;t++){ out = out.concat(flatten(b.children||[])); }
    } else {
      // KEEP 'function' as a step so the runner can "call" it
      out.push({type:b.type, id:b.id});
    }
  }
  return out;
}
  
function checkMouseHoleLanding(){
  var mh = state.mouseHoles && state.mouseHoles.holesByPos;
  if(!mh) return;

  // Cooldown: prevent ping-ponging
  if (state.teleportCooldown &&
      state.teleportCooldown.x === state.pos.x &&
      state.teleportCooldown.y === state.pos.y){
    return;
  }
  if (state.teleportCooldown &&
     (state.teleportCooldown.x !== state.pos.x || state.teleportCooldown.y !== state.pos.y)){
    state.teleportCooldown = null;
  }

  var key = state.pos.x + "," + state.pos.y;
  var hit = mh.get(key);

  if(hit){
    state.teleport = { phase:'queued', dest:{x:hit.x, y:hit.y}, color:hit.color, pairIndex:hit.pairIndex };
    state.teleportCooldown = { x: hit.x, y: hit.y };
  }
}

function injectIfChildrenInto(plan, ip, rootArray, blockId){
    var p = getBlockPathById(rootArray, blockId);
    if (!p) return;
    var container = getContainerByPath(rootArray, p.slice(0,-1));
    if (!container) return;
    var node = container[p[p.length-1]];
    if (!node || !Array.isArray(node.children)) return;
    var sub = flatten(node.children || []);
    if (sub.length){
        Array.prototype.splice.apply(plan, [ip+1, 0].concat(sub));
    }
}


function isIfTrue(choice){
    // where am I?
    const {x, y} = state.pos || {x:0, y:0};

    if (choice === "cheese"){
        return Array.isArray(state.cheeses) &&
            state.cheeses.some(c => c.x===x && c.y===y);
    }
    if (choice === "home"){
        return state.level && state.level.home &&
            state.level.home.x===x && state.level.home.y===y;
    }
    // C1 / C2 / C3 
    if (choice === "C1" || choice === "C2" || choice === "C3"){
        const t = tileAt(x, y);  
        if (t === choice.toUpperCase()) return true;
    }
    return false;
}

function findNodeById(arr, id){
    if (!Array.isArray(arr)) return null;
    for (var i = 0; i < arr.length; i++){
        var b = arr[i];
        if (b && b.id === id) return b;
        // look into containers
        if ((b.type === "repeat" || b.type === "if" || b.type === "repeatUntil") && Array.isArray(b.children)){
            var hit = findNodeById(b.children, id);
            if (hit) return hit;
        }
    }
    return null;
}

// Recursively search a block tree for a type (e.g. "if", "repeat")
function findType(blocks, type) {
  if (!blocks || !blocks.length) return false;
  for (const b of blocks) {
    if (!b) continue;
    if ((b.type || "").toLowerCase() === type) return true;

    // common child containers:
    // - repeat: b.children (array)
    // - if: b.inner || b.children (depending on your model)
    // - generic: b.body, b.then, b.else, etc. (safe checks)
    if (Array.isArray(b.children) && findType(b.children, type)) return true;
    if (Array.isArray(b.inner)    && findType(b.inner, type))    return true;
    if (Array.isArray(b.body)     && findType(b.body, type))     return true;
    if (Array.isArray(b.then)     && findType(b.then, type))     return true;
    if (Array.isArray(b.else)     && findType(b.else, type))     return true;
  }
  return false;
}

// Does either bar contain the type?  Looks in program + (if enabled) function.
function barsContainType(type) {
  const t = (type || "").toLowerCase();
  const inProgram  = findType(state.program, t);
  const inFunction = state.functionEnabled ? findType(state.functionProgram, t) : false;
  return inProgram || inFunction;
}


function stepOnce(fromTimer){
    //  If we finished a function on the previous tick, clean up now
    if (state.fnPlan && state.fnIp >= state.fnPlan.length){
        try { clearFunctionHighlight(); } catch(_){}
        state.fnPlan = null;
        state.fnIp   = 0;
        if (typeof state.ip === 'number'){ state.ip++; } // advance past the call-site
    }

    // Teleportation state machine
    if (state.teleport){
        const stepping = !state.running;  // true when invoked via Step button        

        if (state.teleport.phase === 'queued') {
            // VANISH now
            if (!state.hidden){  // Prevent multiple sounds if the user is clicking stepBtn fast!
                try { beep && beep('hole-in'); } catch(_) {}
            }
            state.hidden = true;
            draw();

            if (stepping) {
                setTimeout(() => {
                    // User might have hit Start; only proceed if still stepping
                    if (!state.running && state.teleport && state.teleport.phase === 'queued') {
                        state.teleport.phase = 'appear';
                        // Re-enter stepOnce to process 'appear' immediately after the pause
                        stepOnce(false);
                    }
                }, TICK_MS);
                return; // consume this click; 'appear' will run after the pause

            } else {
                state.teleport.phase = 'appear';
                return;
            }
        }
        
        if (state.teleport.phase === 'appear') {
            // APPEAR now
            try { beep && beep('hole-out'); } catch(_) {}
            state.pos = { x: state.teleport.dest.x, y: state.teleport.dest.y };
            state.teleportCooldown = { x: state.pos.x, y: state.pos.y };
            state.hidden = false;
            state.teleport = null;
            draw();
            return;
        }
    }


    // If (after returning from the function) the main program is finished, stop & evaluate
    if ((!state.fnPlan || state.fnIp >= state.fnPlan.length) &&
        (typeof state.ip === 'number' && state.ip >= state.plan.length)) {
        if (fromTimer) setRunning(false);
        evaluateWin();
        return;
    }


    // If we are inside a function, execute it first (always step INTO)
        if (state.fnPlan && state.fnIp < state.fnPlan.length){
        var fblk = state.fnPlan[state.fnIp];

        // Keep the program call-site highlighted on every function tick
        if (state.callId) { highlightById(state.callId); }

        // highlight current function block without disturbing program highlight
        highlightFunctionById(fblk.id);

        var stop=false;

        if (fblk.type==="step"){ 
            var v=dirVec(state.dir), nx=state.pos.x+v.x, ny=state.pos.y+v.y; var t=tileAt(nx,ny);
            if(t==="off"||t==="tree"||t==="wall"||t==="water"){ 
            if (t === "off") { 
                try { triggerCatCapture(state.dir); } catch(_){} 
            }
            beep("bonk"); 
            stop=true; 
            } else { 
                state.pos.x=nx; 
                state.pos.y=ny;
                checkMouseHoleLanding(); 
                beep("move");
                if (!state.running && state.teleport) {
                    draw();
                    const TELEPORT_STEP_DELAY = 300;
                    scheduleStepPause(TELEPORT_STEP_DELAY, () => stepOnce(false));
                }
            }
        }
        else if (fblk.type==="turnLeft"){
            state.dir=turnLeft(state.dir); 
            beep("turn"); 
        }
        else if (fblk.type==="turnRight"){
            state.dir=turnRight(state.dir); beep("turn"); 
        }
        else if (fblk.type==="cheese"){ 
            var i = state.cheeses.findIndex(function(c){ return c.x===state.pos.x && c.y===state.pos.y; });
            if(i>=0){ 
                state.cheeses.splice(i,1); 
                beep("pickup"); 
            }
            else { 
                beep("bonk"); 
                stop=true; 
            }
        }
        else if (fblk.type==="function"){
            // Disallow nested calls from function
            // Treat as no-op
        }
        else if (fblk.type === "if"){
            const rootArr = state.functionProgram || [];
            const node = findNodeById(state.functionProgram || [], fblk.id);
            const run = isIfTrue(node && node.choice);
            if (run){
                const kids = (node && Array.isArray(node.children)) ? node.children : [];
                const sub = flatten(kids);
                if (sub.length){
                // nest another level by pushing current fnPlan onto a tiny stack,
                // or simpler: splice sub into current fnPlan at current position
                state.fnPlan.splice(state.fnIp+1, 0, ...sub);
                }
            }
            state.fnIp++;   // consume the IF itself
            return;
        }
        else if (fblk.type === "repeatUntil"){
            const node = findNodeById(state.functionProgram || [], fblk.id);
            const done = isIfTrue(node && node.choice);

            if (done){
                state.fnIp++;           // exit loop in function
            } else {
                // inline-inject children *and* a re-check of the same repeatUntil
                const p = getBlockPathById(state.functionProgram, fblk.id);
                if (p){
                    const container = getContainerByPath(state.functionProgram, p.slice(0,-1));
                    const node = container && container[p[p.length-1]];
                    const kids = (node && Array.isArray(node.children)) ? node.children : [];
                    const sub  = flatten(kids);
                    if (sub.length){
                        // insert: body..., then a self re-check step
                        state.fnPlan.splice(state.fnIp+1, 0, ...sub, { type:'repeatUntil', id: fblk.id });
                        state.fnIp++; // step into the first injected child
                        return;
                    }
                }
                // no children ‚Üí just advance (behaves like an empty loop)
                state.fnIp++;
            }
            return;
        }



        if (stop){
            // highlight offending block as error (in function)
            setErrorHighlight(fblk.id);
            state.halted = true;
            try{ beep("bonk"); }catch(_){}
            if(fromTimer) setRunning(false);
            return;
        }

        state.fnIp++;

        // Evaluate mouse-hole only; defer win until program end (matches program bar behaviour)
        checkMouseHoleLanding();
        draw();
        return;
    }

    // If we're at the end of the program, see if we've stopped on the home square
    if(state.ip>=state.plan.length){ 
        if(fromTimer) setRunning(false); 
        evaluateWin(); 
        return; 
    }

    var blk=state.plan[state.ip]; 
    
    // If this is a function call, "pause" main and enter function
    if (blk.type === "function"){
        // Keep program call highlighted
        highlightById(blk.id);
        state.callId = blk.id;

        // Build function plan from current functionProgram (flattened, repeats expanded)
        var fp = state.functionProgram || [];
        state.fnPlan = flatten(fp);
        state.fnIp   = 0;
        // If function empty, just advance past call next tick
        if (state.fnPlan.length === 0){
            state.fnPlan = null; state.fnIp = 0; state.ip++;
        }
        // No draw here; actual function step will run next tick/next step
        return;
    }

    highlightById(blk.id); 

    var stop=false;

    if(blk.type==="step"){
        var v=dirVec(state.dir), nx=state.pos.x+v.x, ny=state.pos.y+v.y; var t=tileAt(nx,ny);
        if(t==="off"||t==="tree"||t==="wall"||t==="water"){ 
            if (t === "off") { try { triggerCatCapture(state.dir); } catch(_){} }
            
            beep("bonk"); 
            stop=true; 
        } else { 
            state.pos.x=nx; 
            state.pos.y=ny;
            checkMouseHoleLanding(); 
            beep("move"); 
            if (!state.running && state.teleport) {
                draw();
                const TELEPORT_STEP_DELAY = 300;
                scheduleStepPause(TELEPORT_STEP_DELAY, () => stepOnce(false));
            }
        }

    } else if(blk.type==="turnLeft"){ 
        state.dir=turnLeft(state.dir); 
        beep("turn"); 
    }
    else if(blk.type==="turnRight"){ 
        state.dir=turnRight(state.dir); beep("turn"); 
    }
    else if(blk.type==="cheese"){
        var i = state.cheeses.findIndex(function(c){ return c.x===state.pos.x && c.y===state.pos.y; });
        if(i>=0){ state.cheeses.splice(i,1); beep("pickup"); }
        else { beep("bonk"); stop=true; }
    }
    else if (blk.type === "if"){
        // decide
        const node = findNodeById(state.program, blk.id);
        const run  = isIfTrue(node && node.choice);
        if (run){
            injectIfChildrenInto(state.plan, state.ip, state.program, blk.id);
        }
        // either false branch or empty body ‚Üí just advance past IF
        state.ip++;
        return;
    }
    else if (blk.type === "repeatUntil"){
        // find current node in the program to read its 'choice'
        const node = findNodeById(state.program, blk.id);
        const done = isIfTrue(node && node.choice);   // true when on the selected square

        if (done){
            // exit the loop: continue after the repeatUntil
            state.ip++;
            return;
        } else {
            // not done: run the body once, then re-check on next tick
            // inline-inject children *and* a re-check of the same repeatUntil
            const p = getBlockPathById(state.program, blk.id);
                if (p){
                const container = getContainerByPath(state.program, p.slice(0,-1));
                const node = container && container[p[p.length-1]];
                const kids = (node && Array.isArray(node.children)) ? node.children : [];
                const sub  = flatten(kids);
                if (sub.length){
                    // insert: body..., then a self re-check step
                    state.plan.splice(state.ip+1, 0, ...sub, { type:'repeatUntil', id: blk.id });
                    state.ip++; // step into the first injected child
                    return;
                }
            }
            state.ip++;      // step into the first injected child
            return;
        }
    }


    state.ip++; 
    draw(); 

    if(stop){ 
        setErrorHighlight(blk.id); 
        setRunning(false); 
        state.halted = true;
        return; 
    }

    // Evaluate win only if at the end of the program
    if (fromTimer && state.ip >= state.plan.length && (!state.fnPlan || state.fnIp >= state.fnPlan.length)) {
            evaluateWin();
            return;
        }
  }
  

function evaluateWin(){
  var winHome = state.pos.x===state.level.home.x && state.pos.y===state.level.home.y;
  checkMouseHoleLanding();
  if (winHome) {
    var stars = 1;
    try{
      if (state.current){
        var ch = (window.CHALLENGES||[]).find(function(c){
          if(!state.current) return false;
          return c.levelId===state.current.levelId && c.challengeId===state.current.challengeId;
        });
        try{ updateTotalsUI && updateTotalsUI(); }catch(_){}
        try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){}

        if (ch){
            var used = countBlocks(state.program) + (state.functionEnabled ? countBlocks(state.functionProgram) : 0);
            var hadCheese = Array.isArray(state.level.cheeses) && state.level.cheeses.length>0;
            var allCollected = !hadCheese || (Array.isArray(state.cheeses) && state.cheeses.length===0);

            // Base stars on collection + optimalBlocks
            var baseStars = allCollected ? ((used <= (ch.optimalBlocks||0)) ? 3 : 2) : 1;

            // Require certain blocks in the MAIN program (not inside the function bar).
            // 1) function: if enabled, must be called in main program
            // 2) if:       if listed in allowedBlocks, must appear in main program
            var requireChecks = (function computeRequiredUse() {
                const allowed   = (state.level && state.level.allowedBlocks) || [];
                const allowSet  = new Set(allowed.map(s => (s || "").toLowerCase()));

                return {
                    // presence across bars
                    hasIfInBars:     barsContainType("if"),           // program OR function
                    fnInProgram:     findType(state.program, "function"),
                    ifInProgram:     findType(state.program, "if"),   // kept for any legacy uses

                    // requirements driven by allowedBlocks
                    requireIf:       allowSet.has("if"),
                    requireFunction: allowSet.has("function")
                };
                })();

            var stars = baseStars;

            // function required WHEN "function" is among allowed blocks (must be in PROGRAM bar)
            if (requireChecks.requireFunction && !requireChecks.fnInProgram) {
            stars = Math.min(stars, 2);
            }

            // IF required WHEN "if" is among allowed blocks (can be in PROGRAM or FUNCTION bar)
            if (requireChecks.requireIf && !requireChecks.hasIfInBars) {
            stars = Math.min(stars, 2);
            }

            setStarsFor(ch, stars);

            try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){}
            updateTotalsUI();
        }
      }
    }catch(_){}

    scheduleWinAfterOneTick(stars);
  }
}

function highlightById(id){ 
  var prev=document.querySelector('.block.current'); 
  if(prev) prev.classList.remove('current'); 
  if(!id){ return; } var el=(state.blockEls && state.blockEls[id]) || document.querySelector('.program-bar .block[data-id="'+id+'"]'); 
  if(el){ 
    el.classList.add('current'); 
    try{ el.scrollIntoView({block:'nearest', inline:'center'});}catch(_){}} 
}

function clearFunctionHighlight(){
     try{ 
        var prev=document.querySelector('.block.fn-current'); 
        if(prev) prev.classList.remove('fn-current'); 
    }catch(_){}
}

function highlightFunctionById(id){
  clearFunctionHighlight();
  try{
    // Try the map; fallback to a live query in the Function bar
    var el = (state.blockEls && state.blockEls[id]) 
          || document.querySelector('#functionBar .block[data-id="'+id+'"]');
    if (el){
      el.classList.add('fn-current');
      try{ el.scrollIntoView({block:'nearest', inline:'center'});}catch(_){}
    }
  }catch(_){}
}



// === Drawing ===function clearErrorHighlight(){ try{ var e=document.querySelector('.block.error'); if(e) e.classList.remove('error'); }catch(_){} if(state) state.errorId=null; }
function setErrorHighlight(id){ if(state) state.errorId=id; var el=(state.blockEls && state.blockEls[id]) || document.querySelector('.program-bar .block[data-id="'+id+'"]'); if(el){ el.classList.add('error'); el.classList.add('current'); try{ el.scrollIntoView({block:'nearest', inline:'center'});}catch(_){}} }

// === Drawing ===
function drawMouseHoles(cw, ch){
  if(!state.mouseHoles || !state.mouseHoles.pairs || !ctx) return;
  var r = cw*0.25; // radius so diameter = 0.5 * tile width
  var linePx = parseFloat((getCSS("--mhole-border-width")||"4").toString().replace("px","")) || 4;
  // Iterate over pairs; draw both ends for each pair
  for(var i=0;i<state.mouseHoles.pairs.length;i++){
    var pr = state.mouseHoles.pairs[i];
    // Map color id to CSS var
    var stroke = getCSS(pr.color===1?"--mhole-red":pr.color===2?"--mhole-yellow":pr.color===3?"--mhole-green":"--mhole-blue") || "#000";
    // function to draw one hole at grid cell
    function holeAt(cell){
      var cx = (cell.x+0.5)*cw, cy = (cell.y+0.5)*ch;
      // filled black circle
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.fillStyle = "#000"; ctx.fill();
      // colored thick border
      ctx.lineWidth = linePx;
      ctx.strokeStyle = stroke;
      ctx.stroke();
    }
    holeAt(pr.a); holeAt(pr.b);
  }
}

function draw(){
    if(!ctx || !state.level) return;
    updateBoardGeometry();
    var L=state.level, W=state.boardW||board.width, H=state.boardH||board.height; ctx.clearRect(0,0,W,H);
    var cols=L.grid.cols, rows=L.grid.rows; var cell=state.cellSize||Math.min(W/cols,H/rows); var cw=cell, ch=cell;
    
    // Grid
    for(var y=0;y<rows;y++){ for(var x=0;x<cols;x++){
        ctx.fillStyle=getCSS("--tile")||"#dae2ee"; ctx.fillRect(x*cw,y*ch,cw,ch);
        ctx.strokeStyle="rgba(0,0,0,0.18)"; ctx.lineWidth=1; ctx.strokeRect(x*cw,y*ch,cw,ch);
    } }

    // specials
    for(var y2=0;y2<rows;y2++){ for(var x2=0;x2<cols;x2++){
        var t=tileAt(x2,y2);
        if(t==="home"){ ctx.fillStyle=getCSS("--home"); ctx.fillRect(x2*cw,y2*ch,cw,ch); drawHouse(x2*cw,y2*ch,cw,ch); }
        else if(t==="start"){ ctx.fillStyle=getCSS("--start"); ctx.fillRect(x2*cw,y2*ch,cw,ch); }
        else if(t==="tree"){ drawTree(x2*cw,y2*ch,cw,ch); }
        else if(t==="wall"){ drawWall(x2*cw,y2*ch,cw,ch); }
        else if(t==="water"){ drawWater(x2*cw,y2*ch,cw,ch); }
        else if(t==="C1"){ ctx.fillStyle = getCSS("--C1"); ctx.fillRect(x2*cw, y2*ch, cw, ch); }
        else if(t==="C2"){ ctx.fillStyle = getCSS("--C2"); ctx.fillRect(x2*cw, y2*ch, cw, ch); }
        else if(t==="C3"){ ctx.fillStyle = getCSS("--C3"); ctx.fillRect(x2*cw, y2*ch, cw, ch); }
    } }

    // one stroke pass on top
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.lineWidth = 2;
    for (y=0; y<rows; y++) for (x=0; x<cols; x++) {
        ctx.strokeRect(x*cw, y*ch, cw, ch);
    }

    // mouse holes
    drawMouseHoles(cw, ch);

    // cheeses
    for(var k=0;k<state.cheeses.length;k++){ var c=state.cheeses[k]; drawCheeseTile(c.x*cw, c.y*ch, cw, ch); }
    
    // mouse
    drawMouse(state.pos.x*cw+cw/2, state.pos.y*ch+ch/2, Math.min(cw,ch)*0.7, state.dir);
    
    // cat
    if (state.catActive) { drawCatOverlay(cw, ch); }
  }
  
function triggerCatCapture(dir){
    // Hide mouse, show cat, start anim
    state.hidden = true;
    state.catActive = true;
    state.catFx = { t0: performance.now(), dir: dir, duration: 650, progress: 0 };

    // Sound (use existing beep if routed, else fallback to the <audio> tag)
    try {
        var a = document.getElementById('sfxCat');
        if (a) { a.currentTime = 0; a.play().catch(()=>{}); }
    } catch(_){}

    // Drive animation frames even when run has stopped
    if (!state._rafCat){
        const tick = () => {
        if (!state.catActive || !state.catFx){ state._rafCat = null; return; }
        var fx = state.catFx;
        var p = Math.min(1, (performance.now() - fx.t0)/fx.duration);
        fx.progress = p;
        draw();
        if (p < 1){ state._rafCat = requestAnimationFrame(tick); }
        else { state._rafCat = null; } // leave cat visible on the square
        };
        state._rafCat = requestAnimationFrame(tick);
    }
}

function drawCatOverlay(cw, ch){
    if (!state.catActive || !state.catFx || !state.level) return;
    var fx = state.catFx;
    var cols = state.level.grid.cols, rows = state.level.grid.rows;

    // Target: mouse centre (mouse itself is hidden)
    var cx = state.pos.x*cw + cw/2;
    var cy = state.pos.y*ch + ch/2;
    var size = Math.min(cw, ch) * 0.78;

    // Start: just outside the board on the attempted edge
    var sx=cx, sy=cy;
    if (fx.dir === "E") { sx = cols*cw + size; sy = cy; }
    else if (fx.dir === "W") { sx = -size;        sy = cy; }
    else if (fx.dir === "N") { sx = cx;           sy = -size; }
    else if (fx.dir === "S") { sx = cx;           sy = rows*ch + size; }

    // Ease and slight squash for a playful pounce
    var e = easeOutBack(fx.progress);
    var x = sx + (cx - sx) * e;
    var y = sy + (cy - sy) * e;
    var scale = 0.85 + 0.25*Math.sin(e*Math.PI);  // little squash/pop

    drawCat(x, y, size*scale, oppositeDir(fx.dir)); // face inward
}

/**
 * drawCat(ctx, cx, cy, size, dir)
 * Or: drawCat(cx, cy, size, dir)
 */
function drawCat(a,b,c,d,e){
    // --- argument normalization ---
    let ctx, cx, cy, size, dir;
    if (typeof a === "number"){
        cx=a; cy=b; size=c; dir=d;
        const canvas = document.getElementById("board");
        ctx = (window.ctx && typeof window.ctx.save==="function") ? window.ctx :
            (canvas && canvas.getContext ? canvas.getContext("2d") : null);
    } else { ctx=a; cx=b; cy=c; size=d; dir=e; }
    if (!ctx || typeof ctx.save!=="function") return;

    // Rotated 180¬∞ vs the original west-facing base
    const target = (dir==="E")?Math.PI : (dir==="W")?0 : (dir==="N")?Math.PI/2 : -Math.PI/2;
    const angle  = target;

    // Palette
    const outline = "#0e1a22";
    const fur     = "#e5742f";
    const earIn   = "#f7b693";
    const eyeWhite= "#fff";
    const pupil   = "#0b0b0b";
    const whisk   = "#111";

    // Proportions
    const headR  = size*0.22;
    const bodyW  = size*0.80, bodyH = size*0.48;
    const tailW  = size*0.11, tailLen = size*0.5;
    const earW   = size*0.18, earH = size*0.18;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.lineJoin="round";
    ctx.lineCap="round";

    // Shadow
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(0, bodyH*0.34, bodyW*0.60, bodyH*0.33, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Anchors
    const hx = -bodyW*0.56, hy = 0;

    // Tail (draw first so body covers the join)
    (function(){ 
        const r = tailLen;
        ctx.save();
        ctx.translate(bodyW*0.50, bodyH*0.02);
        ctx.strokeStyle = fur; ctx.lineWidth = tailW;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(r*0.22,-r*0.10, r*0.50,-r*0.04, r*0.52, r*0.06);
        ctx.bezierCurveTo(r*0.54, r*0.14, r*0.34, r*0.16, r*0.30, r*0.08);
        ctx.stroke();
        ctx.strokeStyle = outline; ctx.lineWidth = Math.max(1, tailW*0.22); ctx.stroke();
        ctx.restore();
    })();

        // Back legs
    

    // Body
    ctx.fillStyle = fur; ctx.strokeStyle = outline; ctx.lineWidth = Math.max(1,size*0.02);
    ctx.beginPath();
    ctx.ellipse(0, 0, bodyW/2, bodyH/2, 0, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // Head
    ctx.beginPath();
    ctx.arc(hx, hy, headR, 0, Math.PI*2);
    ctx.fillStyle = fur; ctx.fill(); ctx.stroke();

        // Ears (forward)
    function ear(top){
        const ex = hx - headR*0.15;
        const ey = hy + (top ? -headR*0.62 : headR*0.62);
        const s  = top ? -1 : 1;
        ctx.beginPath();
        ctx.moveTo(ex, ey);
        ctx.lineTo(ex - earW*0.70, ey + s*earH*0.45);
        ctx.lineTo(ex + earW*0.20, ey + s*earH*0.15);
        ctx.closePath();
        ctx.fillStyle = fur; 
        ctx.fill(); 
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ex - earW*0.85, ey + s*earH*0.55);
        ctx.lineTo(ex - earW*0.55, ey + s*earH*0.38);
        ctx.lineTo(ex + earW*0.02, ey + s*earH*0.10);
        ctx.closePath();
        ctx.fillStyle = earIn; 
        ctx.fill();
    }
    ear(true); ear(false);

    // forehead "M"
        ctx.strokeStyle = "#b95e25"; ctx.lineWidth = size*0.018;
        for (const s of [-1,1]){
        ctx.beginPath();
        ctx.moveTo(hx - headR*0.50, hy - headR*0.25*s);
        ctx.quadraticCurveTo(hx - headR*0.30, hy - headR*0.05*s, hx - headR*0.15, hy - headR*0.02*s);
        ctx.stroke();
        }
        // two body stripes
        for (const y of [-0.10, 0.12]){
        ctx.beginPath();
        ctx.ellipse(bodyW*0.08, bodyH*y, bodyW*0.28, bodyH*0.16, 0.1, 0, Math.PI);
        ctx.stroke();
        }

    // Face ‚Äî eyes at the very front
    (function(){
        // Eyes: 50% larger than before
        const eyeCx = hx - headR*0.62;   // front of head (toward nose)
        const dy    = headR*0.3;
        const rx    = headR*0.21;        // was 0.14 ‚Üí √ó1.5
        const ry    = headR*0.27;        // was 0.18 ‚Üí √ó1.5

        for (const s of [-1,1]){
        ctx.fillStyle = eyeWhite;
        ctx.beginPath(); ctx.ellipse(eyeCx, hy + s*dy, rx, ry, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();

        // pupil slightly toward the nose edge
        ctx.fillStyle = pupil;
        ctx.beginPath(); ctx.ellipse(eyeCx - rx*0.25, hy + s*dy, rx*0.45, ry*0.55, 0, 0, Math.PI*2); ctx.fill();

        // highlight
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(eyeCx - rx*0.45, hy + s*dy - ry*0.45, Math.max(1, rx*0.20), 0, Math.PI*2); ctx.fill();
        }

        // Nose
        ctx.fillStyle = pupil;
        ctx.beginPath();
        ctx.ellipse(hx - headR*0.92, hy, headR*0.10, headR*0.14, 0, 0, Math.PI*2);
        ctx.fill();

        // Whiskers: two at +45¬∞ and +55¬∞ (up), two at ‚àí45¬∞ and ‚àí55¬∞ (down), all to the left
        ctx.strokeStyle = whisk;
        ctx.lineWidth = Math.max(1, size*0.018);

        const startX = hx - headR*0.80;
        const offsets = [ -headR*0.08, headR*0.08 ]; // slight vertical separation of the pairs
        const anglesDegUp   = [45, 65];
        const anglesDegDown = [-45, -55];
        const len = headR*1.1;

        function drawAtAngle(x0, y0, deg){
        const rad = deg * Math.PI / 180;
        const dx = len * Math.cos(rad);
        const dy = len * Math.sin(rad);
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x0 - dx, y0 - dy);  // extend toward the LEFT at the given angle
        ctx.stroke();
        }

        // Up whiskers (+45¬∞, +55¬∞)
        for (let i=0;i<offsets.length;i++){
        drawAtAngle(startX, hy + offsets[i], anglesDegUp[i]);
        }
        // Down whiskers (‚àí45¬∞, ‚àí55¬∞)
        for (let i=0;i<offsets.length;i++){
        drawAtAngle(startX, hy + offsets[i], anglesDegDown[i]);
        }
    })();

    ctx.restore();
}


function easeOutBack(t){ var c1=1.70158, c3=c1+1; return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2); }
function oppositeDir(d){ return d==="E"?"W": d==="W"?"E": d==="N"?"S":"N"; }


function drawHouse(x,y,w,h){ 
    var cx=x+w/2, cy=y+h/2; ctx.save(); 
    ctx.translate(cx,cy); 
    ctx.fillStyle="#efaa3a"; 
    ctx.fillRect(-w*0.3,0,w*0.6,h*0.35); 
    ctx.fillStyle="#d64c4c"; 
    ctx.beginPath(); 
    ctx.moveTo(-w*0.35,0); 
    ctx.lineTo(0,-h*0.35); 
    ctx.lineTo(w*0.35,0); 
    ctx.closePath(); 
    ctx.fill(); 
    ctx.restore(); 
}

function drawTree(x,y,w,h){
    // background
    try{
        ctx.save(); ctx.translate(x,y);
        var bg = getCSS('--treeBg') || getCSS('--tile') || '#d7dee9';
        ctx.fillStyle = bg; ctx.fillRect(0,0,w,h);

        // thin dark-green border
        ctx.strokeStyle = '#0f4d0f';                  // dark green
        ctx.lineWidth  = Math.max(1, Math.min(w,h)*0.01);
        ctx.strokeRect(1, 1, w-1, h-1);

        ctx.restore();
    }catch(_){}

    // tree
    ctx.save(); ctx.translate(x+w/2,y+h/2);
    ctx.fillStyle = '#3a5d0f';
    ctx.beginPath(); ctx.moveTo(0,-h*0.35); ctx.lineTo(-w*0.28,h*0.1); ctx.lineTo(w*0.28,h*0.1); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(0,-h*0.2);  ctx.lineTo(-w*0.24,h*0.24); ctx.lineTo(w*0.24,h*0.24); ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#6b4c2a';
    ctx.fillRect(-w*0.06, h*0.2, w*0.12, h*0.2);
    ctx.restore();
} 

function drawWall(x,y,w,h){
    ctx.save(); ctx.translate(x,y);

    // background / mortar
    var mortar = getCSS('--wallBg') || getCSS('--tile') || '#d7dee9';
    var brick  = '#a8634a';
    var brickDark = '#8c4e39';
    ctx.fillStyle = mortar; ctx.fillRect(0,0,w,h);

    // brick geometry
    var rows = 4;
    var gap  = Math.max(1, Math.min(w,h)*0.05);
    var r    = Math.max(1, Math.min(w,h)*0.08);
    var bh   = (h - (rows+1)*gap) / rows;

    function rndRect(x0,y0,bw,bh,rad){
        var rr = Math.min(rad, bw/2, bh/2);
        ctx.beginPath();
        ctx.moveTo(x0+rr,y0);
        ctx.lineTo(x0+bw-rr,y0);
        ctx.quadraticCurveTo(x0+bw,y0,x0+bw,y0+rr);
        ctx.lineTo(x0+bw,y0+bh-rr);
        ctx.quadraticCurveTo(x0+bw,y0+bh,x0+bw-rr,y0+bh);
        ctx.lineTo(x0+rr,y0+bh);
        ctx.quadraticCurveTo(x0,y0+bh,x0,y0+bh-rr);
        ctx.lineTo(x0,y0+rr);
        ctx.quadraticCurveTo(x0,y0,x0+rr,y0);
        ctx.closePath();
    }

        // thin orange border
        ctx.strokeStyle = brickDark
        ctx.lineWidth  = Math.max(1, Math.min(w,h)*0.01);
        ctx.strokeRect(1, 1, w-1, h-1);

    for (var row=0; row<rows; row++){
        var yb = gap + row*(bh+gap);
        var cols = 3;
        var bw   = (w - (cols+1)*gap) / cols;
        var offset = (row % 2 === 0) ? 0 : (bw/2 + gap/2);

        // start so that odd rows begin with a true half brick
        var xstart = -offset + gap;

        for (var xb = xstart; xb < w - gap/2; xb += bw + gap){
        var xclamp = Math.max(gap, xb);
        var bwidth = Math.min(bw, w - gap - xclamp);

        // If we spilled past the left margin (odd rows), force half-brick
        if (xb < gap) {
            bwidth = Math.min(bw/2, w - gap - xclamp);
        }

        if (bwidth <= 0) continue;

        rndRect(xclamp, yb, bwidth, bh, r);
        ctx.fillStyle = brick; ctx.fill();
        ctx.strokeStyle = brickDark;
        ctx.lineWidth   = Math.max(1, Math.min(w,h)*0.02);
        ctx.stroke();
        }
    }

    ctx.restore();
}

function drawWater(x,y,w,h){
    ctx.save(); ctx.translate(x,y);

    var g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#bfe7ff');
    g.addColorStop(1, '#87c8f2');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // waves
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    for (var i=0;i<4;i++){
        ctx.beginPath();
        ctx.arc(w*(0.2+0.2*i), h*0.6, w*0.08, 0, Math.PI*2);
        ctx.stroke();
    }

    // thin dark-blue border
    ctx.strokeStyle = '#0b3d91';                    // dark blue
    ctx.lineWidth  = Math.max(1, Math.min(w,h)*0.01);
    ctx.strokeRect(0.5, 0.5, w-1, h-1);

    ctx.restore();
}

function drawCheeseTile(x,y,w,h){
    ctx.save();
    var cx = x + w/2, cy = y + h/2;
    var s = Math.min(w, h) * 0.70;
    ctx.translate(cx, cy);
    var topY = -s*0.45, leftX = -s*0.32, rightX = s*0.32, tipY = s*0.48;
    var lg = ctx.createLinearGradient(0, topY, 0, tipY);
    lg.addColorStop(0, "#ffe58f"); lg.addColorStop(1, "#f4c24a");
    ctx.beginPath(); ctx.moveTo(leftX, topY); ctx.lineTo(rightX, topY); ctx.lineTo(0, tipY); ctx.closePath();
    ctx.fillStyle = lg; ctx.fill();
    ctx.strokeStyle = "#e0a82d"; ctx.lineWidth = Math.max(2, s*0.06); ctx.stroke();
    ctx.save(); ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath(); ctx.arc(leftX + s*0.08, topY + s*0.05, s*0.10, 0, Math.PI*2); ctx.fill(); ctx.restore();
    ctx.beginPath(); ctx.arc(leftX + s*0.08, topY + s*0.05, s*0.10, Math.PI*0.2, Math.PI*1.2); ctx.strokeStyle = "#e0a82d"; ctx.lineWidth = Math.max(2, s*0.06); ctx.stroke();
    ctx.fillStyle = "#dda52a";
    var holes = [{dx:-s*0.10, dy:-s*0.02, r:s*0.06},{dx: s*0.05, dy: s*0.10, r:s*0.08},{dx:-s*0.02, dy: s*0.22, r:s*0.06},{dx: s*0.12, dy: s*0.00, r:s*0.05}];
    holes.forEach(function(hh){ ctx.beginPath(); ctx.arc(hh.dx, hh.dy, hh.r, 0, Math.PI*2); ctx.fill(); });
    ctx.restore();
}

function drawMouse(cx,cy,size,dir){ 
    if (state.hidden) { return; }
    ctx.save(); 
    ctx.translate(cx,cy); 
    var angle=dir==="E"?0:dir==="N"?-1.5708:dir==="S"?1.5708:3.1416; 
    ctx.rotate(angle); 

    // Tail
    ctx.strokeStyle="#f3a3b4"; 
    ctx.lineWidth=Math.max(2,size*0.06); 
    ctx.beginPath(); 
    ctx.moveTo(-size*0.26, size*0.12); 
    ctx.quadraticCurveTo(-size*0.36, size*0.26, -size*0.26, size*0.40); 
    ctx.stroke();

    var g=ctx.createLinearGradient(-size*0.3,0,size*0.3,0); 
    g.addColorStop(0,"#6e6e6e"); 
    g.addColorStop(1,"#8a8a8a"); 
    ctx.fillStyle=g; 
    roundedRect(ctx,-size*0.30,-size*0.22,size*0.60,size*0.44,20); 
    ctx.fill(); 
    ctx.fillStyle="#f5a3ad"; 
    ctx.beginPath(); 
    ctx.arc(-size*0.05,-size*0.22,size*0.09,0,6.283); 
    ctx.fill(); ctx.beginPath(); 
    ctx.arc(-size*0.05,size*0.22,size*0.09,0,6.283); 
    ctx.fill(); 
    ctx.fillStyle="#ffb0bc"; 
    ctx.beginPath(); 
    ctx.arc(size*0.34,0,size*0.08,0,6.283); 
    ctx.fill(); 
    ctx.fillStyle="white"; 
    ctx.beginPath(); 
    ctx.arc(size*0.08,-size*0.10,size*0.08,0,6.283); 
    ctx.fill(); 
    ctx.beginPath(); 
    ctx.arc(size*0.08,size*0.10,size*0.08,0,6.283); 
    ctx.fill(); ctx.fillStyle="#3a3a3a"; 
    ctx.beginPath(); 
    ctx.arc(size*0.12,-size*0.10,size*0.04,0,6.283); 
    ctx.fill(); ctx.beginPath(); 
    ctx.arc(size*0.12,size*0.10,size*0.04,0,6.283); 
    ctx.fill(); ctx.strokeStyle="#2b2b2b"; 
    ctx.lineWidth=2; 
    
    for(var i=-1;i<=1;i+=2){ 
        ctx.beginPath(); 
        ctx.moveTo(size*0.12, i*size*0.10); 
        ctx.lineTo(size*0.26, i*size*0.16); 
        ctx.stroke(); 
        ctx.beginPath(); 
        ctx.moveTo(size*0.12, i*size*0.06); 
        ctx.lineTo(size*0.26, i*size*0.08); 
        ctx.stroke(); 
    } 
    ctx.restore(); }
    function roundedRect(ctx,x,y,w,h,r){ 
        var rr=Math.min(r,w/2,h/2); 
        ctx.beginPath(); 
        ctx.moveTo(x+rr,y); 
        ctx.arcTo(x+w,y,x+w,y+h,rr); 
        ctx.arcTo(x+w,y+h,x,y+h,rr); 
        ctx.arcTo(x,y+h,x,y,rr); 
        ctx.arcTo(x,y,x+w,y,rr); 
        ctx.closePath(); 
}

// === Controls ===
function wireControls(){
  var btnBack = document.getElementById('btnBack');

  if (startBtn) startBtn.addEventListener("click", function(){ 
    
    if(state.running){ 
      state.pauseIntent=true; 
      setRunning(false); 
      
      } else { 
        try{ clearErrorHighlight(); }catch(_){}
        resetToStart();
        setRunning(true);
      } 
  });

  if (stepBtn) stepBtn.addEventListener("click", function(){ 
      if (state.halted) return;  // ignore presses after collision
      if (state.changed) {       // reset if the code's changed
        resetToStart();
      }
      setRunning(false); 
      if(state.ip===0) draw(); 
      if(state.plan.length===0) state.plan = flatten(state.program); 
      stepOnce(false); 
      renderButtons(); 
  });

  if (resetBtn) resetBtn.addEventListener("click", function(){ 
      clearErrorHighlight(); 
      if(typeof clearErrorHighlight==='function'){ clearErrorHighlight(); } 
      resetToStart(); 
      renderButtons(); 
  });

  if (muteToggle) muteToggle.addEventListener("click", function(){ state.soundsMuted = !state.soundsMuted; muteToggle.textContent = state.soundsMuted ? "üîá" : "üîä"; });
  
  if(btnClear){ 
    btnClear.addEventListener("click", function(){ 
      clearErrorHighlight(); 
      if(typeof clearErrorHighlight==='function'){ 
        clearErrorHighlight(); 
      } 
      
      resetToStart(); 
      renderButtons(); 

        
      try{ setRunning(false); }catch(_){}
      state.program=[]; 

      // Added for restoring function to initial state
      // Restore function bar from the level seed, not the mutable snapshot
      if (state.functionEnabled){
      var seed = (state.level && Array.isArray(state.level.functionContents))
          ? state.level.functionContents : [];
      // deep clone to avoid aliasing nested children
      state.functionProgram = JSON.parse(JSON.stringify(seed));

      // (optional) also reset the mutable snapshot so future clears stay correct
      state.functionInit = state.functionProgram.slice();
      }

      renderProgram(); 
      if (state.functionEnabled) renderFunctionBar();
      saveProgram(); }
    )}; 
    
  if(btnBack){ 
        btnBack.addEventListener("click", function(){
        try{ setRunning(false);}catch(_){}
        try{ hideWin(); }catch(_){}
        try{ saveProgram(); }catch(_){}
        var main = document.querySelector("main.layout"); if(main) main.hidden = true;
        var start = document.getElementById("startScreen"); if(start) start.hidden = false;
        try{ updateTopBarForScreen && updateTopBarForScreen(); }catch(_){} updateTopBarForScreen(); updateTopBarForScreen(); if(typeof renderStartScreen==="function") renderStartScreen();
        if(typeof updateTotalsUI==="function") updateTotalsUI();
    }); }
  
}
  
function resetToStart(){ 
    setRunning(false); 
    state.ip=0; 
    state.halted = false;
    state.changed = false;
    state.plan=[]; 

     // Reset the function runner completely
    state.fnPlan = null;
    state.fnIp   = 0;
    state.callId = null;
    try { clearFunctionHighlight(); } catch(_) {}
    try{ var prev=document.querySelector('.block.current'); if(prev) prev.classList.remove('current'); }catch(_){}


    state.pos={x:state.level.start.x, y:state.level.start.y};
    state.hidden = false;             // in case we paused mid-teleport "vanish"
    state.teleport = null;            // cancel any in-flight mouse-hole teleport
    state.teleportCooldown = null;    // clear the 'just came out' cooldown
    checkMouseHoleLanding(); 
    state.dir=state.level.start.dir; 
    state.cheeses=(state.level.cheeses||[]).map(function(c){return {x:c.x,y:c.y};}); 
    hideWin(); 
    state.catActive = false;
    state.catFx = null;
    if (state._rafCat) { cancelAnimationFrame(state._rafCat); state._rafCat = null; }
    document.querySelectorAll('.program-bar .block').forEach(function(n){n.classList.remove('current');}); draw(); 
}
  
// --- Win banner rendering helpers ---
function setWinStars(n){
    var stars = document.querySelectorAll('#winBanner .win-star');
    stars.forEach(function(s, i){
        var on = (i < n);
        var poly = s.querySelector('polygon');
        if(poly){
        poly.setAttribute('fill', on ? '#FFD200' : '#e5e7eb'); // bright yellow vs light grey
        }
    });
}

function setWinMessage(n){
    var el = document.getElementById('winMsg');
    if(!el) return;
    el.textContent = (n>=3) ? 'EXCELLENT!' : 'KEEP GOING!';
}

// Draw mouse in banner (re-use drawMouse by temporarily swapping ctx)
function drawWinMouse(){
    try{
        var c = document.getElementById('winMouse');
        if(!c) return;
        var prevCtx = ctx;
        var local = c.getContext('2d');
        ctx = local;
        ctx.clearRect(0,0,c.width,c.height);
        drawMouse(c.width/2, c.height/2, Math.min(c.width,c.height)*0.45, 'E');
        ctx = prevCtx;
    }catch(_){}
}

function rightArrowSVG(){
    var s=document.createElementNS('http://www.w3.org/2000/svg','svg'); s.setAttribute('viewBox','0 0 24 24');
    var shaft=document.createElementNS(s.namespaceURI,'path');
    shaft.setAttribute('fill','none'); shaft.setAttribute('stroke','currentColor');
    shaft.setAttribute('stroke-width','7'); shaft.setAttribute('stroke-linecap','round'); shaft.setAttribute('stroke-linejoin','round');
    shaft.setAttribute('d','M4 12 H16');
    var head=document.createElementNS(s.namespaceURI,'polygon');
    head.setAttribute('points','15,3 24,12 15,21');
    head.setAttribute('fill','currentColor');
    s.appendChild(shaft); s.appendChild(head); return s;
}

function redoSVG(){
    var s = document.createElementNS('http://www.w3.org/2000/svg','svg');
    s.setAttribute('viewBox','0 0 24 24');
    // Thick round arc (almost full circle), clockwise
    var arc = document.createElementNS(s.namespaceURI,'path');
    arc.setAttribute('fill','none');
    arc.setAttribute('stroke','currentColor');
    arc.setAttribute('stroke-width','5');           // thick, like the reference image
    arc.setAttribute('stroke-linecap','round');
    arc.setAttribute('stroke-linejoin','round');
    // Start around ~220¬∞ and sweep clockwise to ~330¬∞ (leave a gap for the arrowhead)
    // Using large-arc-flag=1, sweep-flag=1 for clockwise sweep
    arc.setAttribute('d','M15 20 A8.5 8.5 0 1 1 17 6.5');
    // Solid triangular head pointing roughly to the right-down direction
    var head = document.createElementNS(s.namespaceURI,'polygon');
    head.setAttribute('points','22,13 20,0 10,10');
    head.setAttribute('fill','currentColor');
    s.appendChild(arc);
    s.appendChild(head);
    return s;
}

function scheduleWinAfterOneTick(stars){
    state.winStarsPending = stars || 0;
    state.winPending = true;

    // If we‚Äôre not running (user pressed Step), there‚Äôs no interval ticking.
    // Emulate exactly one clock pulse with a one-shot timeout that does NOT call stepOnce.
    if (!state.running){
        setTimeout(function(){
        if (state.winPending){
            state.winPending = false;
            showWin(state.winStarsPending);
            try{ beep(state.winStarsPending >= 3 ? "win" : "win12"); }catch(_){}
        }
        }, TICK_MS);
    } 
}

function homeSVG(){
    var s=document.createElementNS('http://www.w3.org/2000/svg','svg'); s.setAttribute('viewBox','0 0 24 24');
    var p=document.createElementNS(s.namespaceURI,'path');
    p.setAttribute('fill','currentColor');
    p.setAttribute('d','M3 11.5l9-8 9 8v8.5a1 1 0 0 1-1 1h-5.5a1 1 0 0 1-1-1V15a1 1 0 0 0-1-1h-1a1 1 0 0 0-1 1v5.5a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-8.5z');
    s.appendChild(p); return s;
}

function showWin(runStars){
    var wb = document.getElementById('winBanner');
    if(!wb) return;
    wb.hidden = false;

    var n = runStars || 0;
    setWinStars(n);
    setWinMessage(n);
    drawWinMouse();

    try{
        var wm = document.getElementById('winMouse');
        if (wm) setCanvasBackingScale(wm);
    }catch(_){}

    var btnHome = document.getElementById('btnWinHome');   // left
    var btnRedo = document.getElementById('btnWinRedo');   // center (only on 3‚òÖ)
    var btnNext = document.getElementById('btnWinNext');   // right

    // Reset icons/classes/handlers/visibility
    [btnHome, btnRedo, btnNext].forEach(function(b){
        if(!b) return;
        b.classList.remove('green','red');
        b.innerHTML = '';
        b.style.display = 'grid';   // default visible; we hide where needed
        b.onclick = null;
    });

    // Left: Home (always)
    if(btnHome){
        btnHome.title = 'Home';
        btnHome.setAttribute('aria-label','Home');
        
        if(typeof homeSVG==='function'){ btnHome.appendChild(homeSVG()); }

        btnHome.onclick = function(){
        try{ setRunning(false);}catch(_){}
        try{ hideWin(); }catch(_){}
        try{ saveProgram(); }catch(_){}
        var main = document.querySelector('main.layout'); if(main) main.hidden = true;
        var start = document.getElementById('startScreen'); if(start) start.hidden = false;
        try{ updateTopBarForScreen && updateTopBarForScreen(); }catch(_){} updateTopBarForScreen(); updateTopBarForScreen(); if(typeof renderStartScreen==='function') renderStartScreen();
        if(typeof updateTotalsUI==='function') updateTotalsUI();
        };
    }

    var three = (n >= 3);

    if(three){
        // Center: red repeat
        if(btnRedo){
        btnRedo.classList.add('red');
        btnRedo.title = 'Retry';
        btnRedo.setAttribute('aria-label','Retry');
        btnRedo.appendChild(redoSVG());
        btnRedo.onclick = function(){ try{ hideWin(); resetToStart(); }catch(_){}};
        }
        // Right: green continue
        if(btnNext){
        btnNext.classList.add('green');
        btnNext.title = 'Continue';
        btnNext.setAttribute('aria-label','Continue');
        btnNext.appendChild(rightArrowSVG());
        btnNext.onclick = function(){
            try{
            if(!state.current) { return; }
            var list = (window.CHALLENGES||[]);
            var idx = list.findIndex(function(c){ return c.levelId===state.current.levelId && c.challengeId===state.current.challengeId; });
            if(idx>=0 && idx < list.length-1){
                var next = list[idx+1];
                hideWin();
                startChallenge(next.levelId, next.challengeId);
            } else {
                if(btnHome && typeof btnHome.onclick==='function') btnHome.onclick();
            }
            }catch(_){}
        };
        }
    } else {
        // 1‚Äì2 stars: two buttons (Home + right red repeat); hide center
        if(btnRedo){ btnRedo.style.display = 'none'; }
        if(btnNext){
        btnNext.classList.add('red');
        btnNext.title = 'Retry';
        btnNext.setAttribute('aria-label','Retry');
        btnNext.appendChild(redoSVG());
        btnNext.onclick = function(){ try{ hideWin(); resetToStart(); }catch(_){}};
        }
    }
}

function hideWin(){
    var wb=document.getElementById('winBanner');
    if(wb) wb.hidden=true;
    state.winPending = false;
}

function syncWidths(){ var boardW = board.getBoundingClientRect().width; var uiW = Math.max(boardW, 840); document.documentElement.style.setProperty('--uiPx', uiW + 'px'); }
  
function buildMouseHoleMaps(level){
    if(!level){ return { holesByPos: new Map(), pairs: [] }; }
    var res = { holesByPos: new Map(), pairs: [] };
    var mh = Array.isArray(level.mouseHoles) ? level.mouseHoles : [];
    mh.forEach(function(p, idx){
        var color = (p.color|0);
        var k1 = p.x1 + "," + p.y1;
        var k2 = p.x2 + "," + p.y2;
        var dest1 = { x: p.x2, y: p.y2, color: color, pairIndex: idx };
        var dest2 = { x: p.x1, y: p.y1, color: color, pairIndex: idx };
        res.holesByPos.set(k1, dest1);
        res.holesByPos.set(k2, dest2);
        res.pairs.push({ color: color, a:{x:p.x1,y:p.y1}, b:{x:p.x2,y:p.y2} });
    });
    return res;
}
    
function applyLevel(lvl){
    state.level = lvl;
    state.mouseHoles = buildMouseHoleMaps(lvl);
    state.teleport = null;
    state.hidden = false;
    state.teleportCooldown = null;

    state.cheeses = (lvl.cheeses||[]).map(function(c){ return {x:c.x,y:c.y}});

    try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){ } 
    if (levelNameEl) {
        const id = state.current ? `${state.current.levelId}.${state.current.challengeId}` : (lvl.id || "");
        levelNameEl.textContent = "";
    try{ updateChallengeStarsUI && updateChallengeStarsUI(); }catch(_){ }                     // clear
        const strong = document.createElement("strong");  // bold "Level X.Y"
        strong.textContent = `Level ${id}`;
        levelNameEl.appendChild(strong);
        levelNameEl.appendChild(document.createTextNode(`: ${lvl.name}`));
    }
    if(optimalEl) optimalEl.textContent=String(lvl.optimalBlocks);
    state.pos={x:lvl.start.x,y:lvl.start.y};
    checkMouseHoleLanding();
    state.dir=lvl.start.dir;
    renderMenu();
    loadProgram();
    if(!Array.isArray(state.program) || !state.program.length){ state.program=[]; }
    renderProgram();
    updateBoardGeometry();
    draw();
}

// Returns a short display name for the chosen folder.
// - If you stored a FileSystemDirectoryHandle: use .name
// - If you stored a path string: use its last segment
// - Else: "No folder chosen"
function getChosenFolderName(){
    const dir = window.SaveSys && SaveSys._dir;

    if (!dir) return "No folder chosen";

    // Handle is a FileSystemDirectoryHandle?
    if (typeof dir === 'object' && dir !== null) {
        if ('name' in dir && typeof dir.name === 'string' && dir.name.trim()) {
        return dir.name.trim();
        }
    }

    // String path fallback: take last non-empty segment
    if (typeof dir === 'string') {
        const parts = dir.split(/[\\/]+/).filter(Boolean);
        if (parts.length) return parts[parts.length - 1];
    }

    // Last resort: readable string
    return String(dir);
}

// Creates the badge if missing and updates its text + title
function updateChosenFolderUI(){
    let badge = document.getElementById('chosenFolderBadge');

    // If your toolbar is dynamic, inject the badge on demand
    if (!badge) {
        const btn = document.getElementById('chooseSaveFolderBtn');
        if (btn && btn.parentNode) {
        badge = document.createElement('span');
        badge.id = 'chosenFolderBadge';
        badge.className = 'path-pill';
        btn.parentNode.insertBefore(badge, document.getElementById('playerSelect'));
        }
    }

    if (!badge) return;

    const name = getChosenFolderName();
    badge.textContent = name;
    badge.title = (window.SaveSys && SaveSys._dir) ? String(SaveSys._dir) : "No folder chosen";
}


function init(){
    try{
        board=document.getElementById("board"); ctx=board && board.getContext && board.getContext("2d");
        programBar=document.getElementById("programBar"); blockMenu=document.getElementById("blockMenu");
        startBtn=document.getElementById("btnStart"); stepBtn=document.getElementById("btnStep"); resetBtn=document.getElementById("btnReset"); btnPlay=startBtn;
        optimalEl=document.getElementById("optimalBlocks"); yourEl=document.getElementById("yourBlocks"); levelNameEl=document.getElementById("levelName");
        
        // Wire top-bar buttons
        muteToggle = document.getElementById('muteToggle');
        btnClear   = document.getElementById('btnClear');
        if(!board||!ctx){ showError("Canvas context unavailable"); return; }
        syncWidths(); window.addEventListener("resize", syncWidths);
        wireControls(); renderButtons(); document.querySelector('main.layout').hidden = true; var start = document.getElementById('startScreen'); if(start) start.hidden = false; renderStartScreen();
        try{ updateTopBarForScreen && updateTopBarForScreen(); }catch(_){}
    }
    catch(e){ showError("init()", e); }
}
  

document.addEventListener("DOMContentLoaded", init);
// Global dragleave to catch leaving the window/grey areas
document.addEventListener('dragleave', function(e){ overDropzone=false; });
document.addEventListener('drop', function(e){ if(!e.target.closest || !e.target.closest('.dropzone')){ overDropzone=false; } });
window.addEventListener("resize", resizeLayout);

if (window.visualViewport){
  window.visualViewport.addEventListener("resize", resizeLayout);
  window.visualViewport.addEventListener("scroll", resizeLayout);
}

/* === Shared local saves via OneDrive folder (File System Access API) === */
(function(){
    const HANDLE_KEY = 'hc_saves_dir_v1';
    const LAST_PLAYER_KEY = 'hc_last_player_v1';

    function idbOpen(){ return new Promise((res, rej) => { const req = indexedDB.open('hc-game-saves', 1); req.onupgradeneeded = () => req.result.createObjectStore('kv'); req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error); }); }
    async function idbSet(key, val){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx=db.transaction('kv','readwrite'); tx.objectStore('kv').put(val,key); tx.oncomplete=res; tx.onerror=()=>rej(tx.error); }); }
    async function idbGet(key){ const db = await idbOpen(); return new Promise((res, rej)=>{ const tx=db.transaction('kv','readonly'); const rq=tx.objectStore('kv').get(key); rq.onsuccess=()=>res(rq.result); rq.onerror=()=>rej(rq.error); }); }

    async function verifyPermission(handle, mode='readwrite'){ try{ if(await handle.queryPermission({mode})==='granted') return true; return (await handle.requestPermission({mode}))==='granted'; }catch(e){ return false; } }
    
    async function chooseSaveDir(){ 
        if(!('showDirectoryPicker' in window)){ 
            alert('Chrome/Edge required for shared local saves.'); 
            return null; 
        } 
        const dir=await window.showDirectoryPicker({startIn:'documents'}); 
        if(!(await verifyPermission(dir))) { 
            alert('Permission denied.'); 
            return null; 
        } 
        await idbSet(HANDLE_KEY, dir); 
        SaveSys._dir=dir; 
        try{ updateChosenFolderUI(); }catch(_){}
        return dir; 
    }

    async function ensureSaveDir(){ 
        if(SaveSys._dir) return SaveSys._dir; 
        const stored=await idbGet(HANDLE_KEY); 
        if(stored && await verifyPermission(stored)){ 
            SaveSys._dir=stored; 
            try{ updateChosenFolderUI(); }catch(_){}
            return stored; 
        } 
        return null; 
    }
    
    async function readTextFile(dir, name){ try{ const fh=await dir.getFileHandle(name,{create:false}); const f=await fh.getFile(); return await f.text(); }catch(e){ return null; } }
    async function writeTextFile(dir, name, text){ const fh=await dir.getFileHandle(name,{create:true}); const w=await fh.createWritable({keepExistingData:false}); await w.write(text); await w.close(); }

    function challengeKey(ch){ return (ch.levelId + '_' + ch.challengeId); }

    function snapshotLocalProgress(){
        const out={version:1,challenges:{},totals:{}};
        try{
        (window.CHALLENGES||[]).forEach(function(ch){
            const key=challengeKey(ch);
            const program = (typeof loadProgFor==='function') ? (loadProgFor(ch)||[]) : [];
            const fn      = (typeof loadFnFor ==='function') ? (loadFnFor(ch) ||[]) : [];
            const stars   = (typeof getStarsFor==='function') ? (getStarsFor(ch)||0) : 0;
            out.challenges[key] = { program, fn, stars };
        });
        out.totals.stars = (typeof totalAchievedStars==='function') ? totalAchievedStars() : 0;
        }catch(e){}
        return out;
    }

    function blankSnapshot(){
        const out = { version: 1, challenges: {}, totals: { stars: 0 } };
        (window.CHALLENGES || []).forEach(function(ch){
            out.challenges[ch.levelId + "_" + ch.challengeId] = {
                program: [],
                fn: [], 
                stars: 0
            };
        });
        return out;
    }

    function setStarsExact(ch, n){
        try{
            if (!ENABLE_LOCAL_SAVE){
            if (window.SaveSys && SaveSys._snapshot){
                const key = challengeKey(ch);
                const rec = SaveSys._snapshot.challenges[key] || (SaveSys._snapshot.challenges[key] = { program:[], fn:[], stars:0 });
                rec.stars = Number(n)||0;
                if (SaveSys._snapshot.totals) { SaveSys._snapshot.totals.stars = totalAchievedStars(); }
            }
            return;
            }
            localStorage.setItem("hc_v2_stars_"+challengeKey(ch), String(Number(n)||0));
        }catch(_){}
    }


    function applySnapshot(data){
        if(!data||typeof data!=='object') return;
        SaveSys._snapshot = data;  // ‚Üê keep the current player's snapshot in memory

        try{
            (window.CHALLENGES||[]).forEach(function(ch){
                if (ENABLE_LOCAL_SAVE){ try{ localStorage.removeItem("hc_v2_prog_"+challengeKey(ch)); }catch(_){} }
                if (ENABLE_LOCAL_SAVE){ try{ localStorage.removeItem("hc_v2_fn_"  +challengeKey(ch)); }catch(_){} }
                if (ENABLE_LOCAL_SAVE){ try{ localStorage.removeItem("hc_v2_stars_"+challengeKey(ch)); }catch(_){} }
            }
        );

        (window.CHALLENGES||[]).forEach(function(ch){
            const key=challengeKey(ch); 
            const rec=(data.challenges||{})[key];
            if(!rec) return;

            try{ if(typeof saveProgFor==='function') saveProgFor(ch, Array.isArray(rec.program)? rec.program : []); }catch(_){}
            try{ if(typeof saveFnFor  ==='function') saveFnFor  (ch, Array.isArray(rec.fn)     ? rec.fn      : []); }catch(_){}
            try{ setStarsExact(ch, Number(rec.stars)||0); }catch(_){}
        });
        }catch(_){}

        try{ if(typeof updateTotalsUI==='function') updateTotalsUI(); }catch(_){}
        try{ if(typeof renderStartScreen==='function') renderStartScreen(); }catch(_){}
        try{ if(typeof updateChallengeStarsUI==='function') updateChallengeStarsUI(); }catch(_){}
    }

    function playerFileName(id){ return "player-"+id+".json"; }
    
    const PLAYER_FILE_PREFIX = "player-";
    const PLAYER_FILE_EXT = ".json";

    function isPlayerFileName(name){
        return name.startsWith(PLAYER_FILE_PREFIX) && name.endsWith(PLAYER_FILE_EXT);
    }
    function playerIdFromFile(name){
        return name.slice(PLAYER_FILE_PREFIX.length, name.length - PLAYER_FILE_EXT.length);
    }

    async function loadPlayersIndex(){
        const dir = await ensureSaveDir();
        const players = [];
        if (!dir) return players;

        // enumerate entries and take only "player-*.json"
        for await (const [name, handle] of dir.entries()){
            if (handle.kind === "file" && /^player\-.*\.json$/i.test(name)){
            try{
                const file = await handle.getFile();
                const text = await file.text();
                const data = JSON.parse(text);
                
                // Minimum shape; fallback to id from filename if needed
                const idFromName = name.slice("player-".length, name.length - ".json".length);
                const meta = (data && data.meta) ? data.meta : {};
                const id = meta.id || data?.id || idFromName;

                // Choose the label: originalName > name > data.name > idFromName
                const nm = meta.originalName || meta.name || data?.name || idFromName;

                if (id && nm) players.push({ id, name: nm });

            }catch(_){ /* ignore corrupt files */ }
            }
        }

        // Alphabetical sort (your UI expects this)
        players.sort((a,b) => a.name.localeCompare(b.name, 'en', {sensitivity:'base'}));
        return players;
    }

    async function loadPlayerFromDisk(id){ const dir=await ensureSaveDir(); if(!dir) throw new Error('No save folder'); const txt=await readTextFile(dir, playerFileName(id)); if(!txt) return null; try{ return JSON.parse(txt); }catch(_){ return null; } }
    async function savePlayerToDisk(id, payload){ const dir=await ensureSaveDir(); if(!dir) throw new Error('No save folder'); payload.lastUpdated=new Date().toISOString(); await writeTextFile(dir, playerFileName(id), JSON.stringify(payload,null,2)); }

    const SaveSys = {
        _dir:null,
        currentPlayerId:null,

        async chooseFolder(){ 
            if (ENABLE_LOCAL_SAVE) return;   // ‚Üê no folder selection in local mode
            const d=await chooseSaveDir();
            
             // reset selection so UI shows the placeholder
            this.currentPlayerId = null;
            if (ENABLE_LOCAL_SAVE){ try { localStorage.removeItem(LAST_PLAYER_KEY); } catch (_){}} 

            await this.refreshPlayersUI(); 
            try{
              updateChosenFolderUI();
            }catch(_){} return d; 
        },


        async refreshPlayersUI(){
            const sel = document.getElementById('playerSelect');
            if (!sel) return;

            // If no folder chosen yet, clear and bail
            if (!this._dir) {
                // try to pick up a previously authorized directory
                await ensureSaveDir();
                if (!this._dir) {
                    // still none; show the ‚Äúchoose‚Äù option only
                    sel.innerHTML = '<option value="">(choose player)</option>';
                    this.players = [];
                    this.users   = [];
                    refreshStartScreenLockState && refreshStartScreenLockState();
                    return;
                }
            }

            const players = await loadPlayersIndex();   // <-- fixed call

            // cache for Guards.canPlay()
            this.players = players;
            this.users   = players;

            // Rebuild the dropdown
            sel.innerHTML = '<option value="">(choose player)</option>';
            players.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = p.name || p.id;
                sel.appendChild(opt);
            });

            // Keep selected if we have one
            if (this.currentPlayerId){
                try { sel.value = this.currentPlayerId; } catch(_) {}
            } else {
            // ensure the visible text isn‚Äôt blank
            try { sel.value = ""; } catch(_){}
            }

            refreshStartScreenLockState && refreshStartScreenLockState();
            },
        

        async newPlayer(){ 
            if (ENABLE_LOCAL_SAVE) return;   // ‚Üê block creating JSON players in local mode
            const name=prompt('New player name:'); 
            if(!name) return; 

            const id=name.trim().toLowerCase().replace(/[^a-z0-9_-]/g,'-')||('p'+Date.now()); 
            
            // Create the player snapshot file (one file per player)
            const payload = blankSnapshot();
            payload.meta = { id, name, originalName: name, createdAt: new Date().toISOString() };
            await savePlayerToDisk(id, payload); 

            // Select this player and refresh UI
            this.currentPlayerId = id; 
            await this.refreshPlayersUI(); 
            await this.selectPlayer(id); 

            // Ensure the dropdown shows it
            const sel = document.getElementById('playerSelect');
            if (sel) sel.value = id;
            try { updateCurrentUserUI(); } catch(_) {}
        },

        async selectPlayer(id){ 
            if (ENABLE_LOCAL_SAVE) return;   // ‚Üê never load/apply JSON in local mode

            if(!id) return; this.currentPlayerId=id; 
            if (ENABLE_LOCAL_SAVE){ try{ localStorage.setItem(LAST_PLAYER_KEY,id);}catch(_){} }
            const sel0 = document.getElementById('playerSelect'); // immediate sync
            if (sel0) sel0.value = id;
            const data=await loadPlayerFromDisk(id);
            if (data) {
                applySnapshot(data);
                } else {
                const payload = blankSnapshot();
                payload.meta = { id, name: id, originalName: id };
                await savePlayerToDisk(id, payload);
                applySnapshot(payload);   // show zero progress right away
                }
            try{ if(typeof updateTotalsUI==='function') updateTotalsUI(); }catch(_){}
            try{ if(typeof renderStartScreen==='function') renderStartScreen(); }catch(_){}
            
            // If renderStartScreen rebuilt the header, re-sync once the DOM settles:
            setTimeout(()=>{ const sel = document.getElementById('playerSelect'); if (sel) sel.value = id; }, 0);
            try { updateCurrentUserUI(); } catch(_) {}

        },

        async saveNow(){
            if (ENABLE_LOCAL_SAVE) return;   // ‚Üê block JSON writes in local mode
            if(!this.currentPlayerId) return;

            // Start from current local progress
            const payload = snapshotLocalProgress();

            // Merge existing on-disk meta so name/originalName are preserved
            let prevMeta = {};
            try {
                const existing = await loadPlayerFromDisk(this.currentPlayerId);
                if (existing && typeof existing.meta === 'object') prevMeta = existing.meta;
            } catch(_) {}

            payload.meta = {
                ...prevMeta,                           // keep originalName, name, createdAt, etc.
                id: this.currentPlayerId,              // always ensure id is correct
                // If a very old file lacks names, backfill them sensibly:
                name: prevMeta.name || prevMeta.originalName || prevMeta.id || this.currentPlayerId,
                originalName: prevMeta.originalName || prevMeta.name || this.currentPlayerId
            };

            await savePlayerToDisk(this.currentPlayerId, payload);
        },

        async bootstrap(){ 
            await ensureSaveDir(); 
            await this.refreshPlayersUI(); 
            
            if (!ENABLE_LOCAL_SAVE) {
                let last = null;
                try { last = localStorage.getItem(LAST_PLAYER_KEY); } catch(_){}
                if (last){
                await this.selectPlayer(last);
                const sel = document.getElementById('playerSelect');
                if (sel) sel.value = last;
                }
            }
        }
    };
  window.SaveSys = SaveSys;

    

  window.addEventListener('DOMContentLoaded', function(){
    const btnChoose=document.getElementById('chooseSaveFolderBtn');
    const sel=document.getElementById('playerSelect');
    const btnNew=document.getElementById('newPlayerBtn');

    if(btnChoose && !btnChoose.dataset.wired){ 
      btnChoose.addEventListener('click', async()=>{ 
        await SaveSys.chooseFolder();
        refreshStartScreenLockState();  
      }); 
      btnChoose.dataset.wired='1';}

    if(btnNew && !btnNew.dataset.wired){ 
      btnNew.addEventListener('click', async()=>{ 
        await SaveSys.newPlayer();
        setTimeout(function(){
          refreshStartScreenLockState();
          updateCurrentUserUI && updateCurrentUserUI();
        }, 0);
      }); 
      btnNew.dataset.wired='1';}

    if(sel && !sel.dataset.wired){ 
      sel.addEventListener('change', async()=>{ 

        if (!sel.value) {
            // Clear current player and lock the UI
            if (window.SaveSys) {
            SaveSys.currentPlayerId = "";
            if (ENABLE_LOCAL_SAVE){ try { localStorage.removeItem(LAST_PLAYER_KEY); } catch (_){} }
            }
            // Make sure UI reflects "(choose player)"
            try { sel.value = ""; } catch(_) {}
            refreshStartScreenLockState();
            updateCurrentUserUI && updateCurrentUserUI();
            return;
        }
        
        // Normal path: a real player was chosen
        await SaveSys.selectPlayer(sel.value); 

        // Ensure RAM doesn't hold the previous player's blocks
        state.program = [];
        state.functionProgram = [];

        // Re-render both bars and counts so stale DOM is wiped
        try { if (typeof renderProgram === 'function') renderProgram(); } catch (_){}
        try { if (typeof renderFunctionBar === 'function') renderFunctionBar(); } catch (_){}
        try { if (typeof updateYourBlocksCount === 'function') updateYourBlocksCount(); } catch (_){}

        refreshStartScreenLockState();
        updateCurrentUserUI && updateCurrentUserUI();

      }); 
      sel.dataset.wired='1';}

    SaveSys.bootstrap(); // Load on startup
    try{ resizeLayout(); }catch(_){}

    // On initial load, render + enforce guards
    try { 
      renderStartScreen && renderStartScreen(); 
    } catch(_){}
    refreshStartScreenLockState();
    updateChosenFolderUI();
  });


  // Hook save when win banner is shown
  try{
        const __origShowWin = window.showWin;
        window.showWin = function(runStars){
        try{  
            // Only persist to JSON in JSON mode
            if (!ENABLE_LOCAL_SAVE && window.SaveSys) SaveSys.saveNow(); 
        }catch(e){}
        return __origShowWin ? __origShowWin(runStars) : undefined;
        };
  }catch(e){}
})();
</script>
</body>
</html>
